using System.Collections.Generic;
using UnityEditor;
using UnityEngine;
using System.IO;
using System.Text.RegularExpressions;
using System;
using System.Diagnostics;
using UnityEngine.UI;
// using System.Reflection;
using UnityEditor.SceneManagement;
using UnityEngine.Rendering;

[InitializeOnLoad]
public class SrJFqU_AAyGB_m4_fj4D3_52a0G4A_72
{
    public static DateTime[] lastWriteTime;
    public static Dictionary<string, string> shadernames;
    public static Dictionary<string, string[]> scriptclassnames;
    public static string[] cgincandhlsl;
    public static bool shouldbe;
    private static string FindClassHelper(int startpos, int pL, string sourcestr)
    {
        string temp = string.Empty;
        int sourcestrL = sourcestr.Length;
        bool IsTemp = false;
        int startposfront = startpos + pL;
        int spl = startpos - 1;
        if ((spl > 0 && sourcestr[spl] != ' ') || (startposfront < sourcestrL && sourcestr[startposfront] != ' '))
        {
            return temp;
        }
        for (int i = startposfront; i < sourcestrL; i++)
        {
            char sourcechar = sourcestr[i];
            if ((sourcechar == ' ' ||
            sourcechar == ':' ||
            sourcechar == '{' ||
            sourcechar == '<' ||
            sourcechar == '\r' ||
            sourcechar == '\n')
             && IsTemp)
            {
                break;
            }
            else if (sourcechar != ' ')
            {
                temp += sourcechar;
                IsTemp = true;
            }
        }
        return temp;
    }
    private static Dictionary<int, string> FindClass(string sourcestring, string classpattern, string interfacepattern)
    {
        Dictionary<int, string> temp = new Dictionary<int, string>();
        int classindex = -1;
        int interfaceindex = -1;
        bool Isinterfaceindex = true;
        bool Isclassindex = true;
        int classpatternL = classpattern.Length;
        int interfacepatternL = interfacepattern.Length;
        do
        {
            if (Isclassindex)
            {
                classindex = sourcestring.IndexOf(classpattern, classindex + 1);
            }
            if (Isinterfaceindex)
            {
                interfaceindex = sourcestring.IndexOf(interfacepattern, interfaceindex + 1);
            }
            if (classindex != -1)
            {
                string tempstring = FindClassHelper(classindex, classpatternL, sourcestring);
                if (tempstring != string.Empty)
                {
                    temp.Add(classindex, tempstring);
                }
            }
            else
            {
                Isclassindex = false;
            }
            if (interfaceindex != -1)
            {
                string tempstring = FindClassHelper(interfaceindex, interfacepatternL, sourcestring);
                if (tempstring != string.Empty)
                {
                    temp.Add(interfaceindex, tempstring);
                }
            }
            else
            {
                Isinterfaceindex = false;
            }
        } while (Isclassindex || Isinterfaceindex);
        return temp;
    }
    public static void CodeChangeDetect(string[] allscripts, out bool IsDifferent)
    {
        IsDifferent = false;
        for (int i = 0; i < allscripts.Length; i++)
        {
            string sc = allscripts[i];
            string scontent = File.ReadAllText(sc);
            if (scontent.Contains("ASET2"))
            {
                string shouldbe2 = string.Empty;
                FileInfo fileInfo = new FileInfo(sc);
                DateTime filecreatime = fileInfo.CreationTime;
                DateTime filelastime = fileInfo.LastWriteTime;
                TimeSpan realdeltatime = filelastime - filecreatime;
                int realtime = realdeltatime.Hours * 60 * 60 + realdeltatime.Minutes * 60 + realdeltatime.Seconds;
                if (realtime < 1)
                {
                    shouldbe = IsDifferent;
                }
                else
                {
                    // File.WriteAllText(sc, shouldbe2);
                    IsDifferent = true;
                    shouldbe = IsDifferent;
                }
                break;
            }
        }
    }
    public static void LASS(string[] assetsshaders, int ShaderL, string[] includes, int includesL)
    {
        shadernames = new Dictionary<string, string>();
        scriptclassnames = new Dictionary<string, string[]>();
        cgincandhlsl = new string[1];
        string withoutnote = @"(\/\/.*$)|(\/\*(.|\n)*?\*\/)";

        cgincandhlsl = new string[includesL];

        includes.CopyTo(cgincandhlsl, 0);


        string[] guidScript = Directory.GetFiles("Assets", "*.cs", SearchOption.AllDirectories);

        // CodeChangeDetect(guidScript, out bool _fj__J__EqS);
        // if ( _fj__J__EqS )  
        //     return ;
        int ScriptL = guidScript.Length;
        int ShaderAndScriptsL = Mathf.Max(ScriptL, ShaderL);
        for (int j = 0; j < ShaderAndScriptsL; j++)
        {
            if (j < ShaderL)
            {

                string shaderpath = assetsshaders[j].Replace("\\", "/");
                string shadercontents = File.ReadAllText(shaderpath);


                MatchCollection notes = Regex.Matches(shadercontents, withoutnote, RegexOptions.Multiline);
                string shadercontentsexp = shadercontents;
                for (int k = 0; k < notes.Count; k++)
                {
                    Match noteM = notes[k];
                    if (!ASET2.IsInQuotationMarks(shadercontents, noteM.Index, 2))
                    {
                        shadercontentsexp = shadercontentsexp.Replace(noteM.Value, string.Empty);
                    }
                }
                string shadername = ASET2.Clampstring(0, shadercontentsexp.Length, shadercontentsexp, '"', '"', true);
                if (shadername != string.Empty)
                {
                    shadernames.Add(shaderpath, shadername);
                }
            }
            if (j < ScriptL)
            {

                string scriptpath = guidScript[j].Replace("\\", "/");
                string scriptcontents = File.ReadAllText(scriptpath);

                string scriptcontentsexp = Regex.Replace(scriptcontents, withoutnote, string.Empty, RegexOptions.Multiline);

                Dictionary<int, string> classes = FindClass(scriptcontentsexp, "class", "interface");
                List<string> allclasses = new List<string>();
                foreach (int k in classes.Keys)
                {
                    string classtemp = classes[k];
                    if (!ASET2.IsInQuotationMarks(scriptcontentsexp, k, 2))
                    {
                        allclasses.Add(classtemp);
                    }
                }
                scriptclassnames.Add(scriptpath, allclasses.ToArray());
            }
        }
    }
    public static void DiffShaderLength(string[] nowshaders, int nowshadersL)
    {
        lastWriteTime = new DateTime[nowshadersL];
        for (int i = 0; i < nowshadersL; i++)
        {
            string shaderpath = nowshaders[i];
            FileInfo fileInfo = new FileInfo(shaderpath);
            lastWriteTime[i] = fileInfo.LastWriteTime;
        }
    }
    private static void LASSapply()
    {
        if (!EditorApplication.isPlayingOrWillChangePlaymode)
        {
            string StringassetsL = "Assets";
            string[] guidShader = Directory.GetFiles(StringassetsL, "*.shader", SearchOption.AllDirectories);
            string[] cgincInAssets = Directory.GetFiles(StringassetsL, "*.cginc", SearchOption.AllDirectories);
            string[] hlslInAssets = Directory.GetFiles(StringassetsL, "*.hlsl", SearchOption.AllDirectories);
            int guidShaderL = guidShader.Length;
            int guidCgincL = cgincInAssets.Length;
            int guidHlslL = hlslInAssets.Length;
            int guidCgincNHlslL = guidCgincL + guidHlslL;
            int guidAllL = guidShaderL + guidCgincNHlslL;
            string[] guids = new string[guidAllL];
            string[] guidscgincNhlsl = new string[guidCgincNHlslL];
            cgincInAssets.CopyTo(guidscgincNhlsl, 0);
            hlslInAssets.CopyTo(guidscgincNhlsl, guidCgincL);
            guidShader.CopyTo(guids, 0);
            guidscgincNhlsl.CopyTo(guids, guidShaderL);
            DiffShaderLength(guids, guidAllL);
            LASS(guidShader, guidShaderL, guidscgincNhlsl, guidCgincNHlslL);
            EditorApplication.update -= LASSapply;
        }
    }
    static SrJFqU_AAyGB_m4_fj4D3_52a0G4A_72()
    {
        EditorApplication.update += LASSapply;
    }
}
public class ASET2 : EditorWindow
{
    private static ASET2 wnd = null;
    [MenuItem("Assets/Assets Sorting Exporter v2.0")]
    private static void InitWindow()
    {
        if (EditorApplication.isPlaying)
        {
            wnd.Close();
            return;
        }
        if (wnd != null)
        {
            wnd.Close();
        }
        // bool firstcs = SrJFqU_AAyGB_m4_fj4D3_52a0G4A_72.shouldbe;
        // if ( firstcs )
        // {
        //     wnd.Close();
        //     return ;
        // }
        wnd = (ASET2)GetWindow(typeof(ASET2));
        wnd.titleContent = new GUIContent("Assets Sorting Exporter v2.0");
        wnd.minSize = new Vector2(450, 450);
        wnd.Show();
    }
    private void ShowButton(Rect ShowButtonposition)
    {
        if (GUI.Button(ShowButtonposition, EditorGUIUtility.IconContent("_Help"), GUI.skin.FindStyle("IconButton")))
        {
            string fullPath = Path.Combine(Application.dataPath, "Editor/AssetSort/Assets Sorting Exporter Introduction.pdf");
            if (File.Exists(fullPath))
            {
                try
                {
                    Process.Start(fullPath);
                }
                catch (System.Exception e)
                {
                    UnityEngine.Debug.LogError("Unable to open file: " + e.Message);
                }
            }
            else
            {
                UnityEngine.Debug.LogError("File not found: " + fullPath);
            }
        }
    }
    private void FindcsAndshader(string fp, Dictionary<string, string> Sn, Dictionary<string, string[]> Scn, string[] cah, List<string> allfilesinasset)
    {
        if (IsSuff(fp, ".cs"))
        {
            IsScriptinScript(fp, Sn, Scn, cah, allfilesinasset);
        }
        else if (IsSuff(fp, ".shader"))
        {
            IsScriptinShader(fp, Sn, Scn, cah, allfilesinasset);
        }
    }

    public static string Clampstring(int startpos, int endpos, string str, char charstart, char charend, bool IsEnterKey)
    {
        string temp = string.Empty;
        if (charstart == charend)
        {
            int IsTwice = 0;
            for (int i = startpos; i < endpos; i++)
            {
                char stri = str[i];
                bool WhenStop = IsEnterKey ? (stri == '\r' || stri == '\n') : (stri == ';' || stri == '{' || stri == '}');
                if (stri == charstart)
                {
                    IsTwice++;
                    if (IsTwice == 2)
                    {
                        break;
                    }
                }
                else if (stri != charend && IsTwice == 1)
                {
                    temp += stri;
                }
                else if (WhenStop)
                {
                    break;
                }
            }
        }
        else
        {
            bool Istemp = false;
            for (int i = startpos; i < endpos; i++)
            {
                char stri = str[i];
                if (stri == charstart)
                {
                    Istemp = true;
                }
                else if (stri != charstart && stri != charend && Istemp)
                {
                    temp += stri;
                }
                else if (stri == charend || stri == '\r' || stri == '\n')
                {
                    break;
                }
            }
        }
        return temp;
    }

    private static readonly string withoutnote = @"(\/\/.*$)|(\/\*(.|\n)*?\*\/)";
    public class ShaderIncludeON
    {
        public string oldname;
        public string newname;
        public string newpath;
        public ShaderIncludeON(string Oe2g_____82, string _II__YZ__4, string Xl__k3_V_v)
        {
            oldname = Oe2g_____82;
            newname = _II__YZ__4;
            newpath = Xl__k3_V_v;
        }
    }
    private Dictionary<string, ShaderIncludeON> shaderincludes = new Dictionary<string, ShaderIncludeON>();
    private List<string> ShaderScriptInclude(string pattern, string sourcestring, char areastart, char areaend)
    {
        int sourcestringLength = sourcestring.Length;
        List<string> temp = new List<string>();
        int index = -1;
        do
        {
            index = sourcestring.IndexOf(pattern, index + 1);
            if (index != -1)
            {
                string tempstring = Clampstring(index + pattern.Length, sourcestringLength, sourcestring, areastart, areaend, true);
                if (tempstring != string.Empty)
                {
                    temp.Add(tempstring);
                }
            }
        } while (index != -1);
        return temp;
    }
    private static bool IsInQuotationMarksHelper(string sg, int startindex, char pattern)
    {
        int ipre = startindex;


        while (ipre > 0 && sg[ipre] != '\r' && sg[ipre] != '\n')
        {
            if (sg[ipre] == pattern)
            {
                return true;
            }

            ipre--;
        }
        return false;
    }
    public static bool IsInQuotationMarks(string sg, int patternIndex, int stringLength)
    {
        switch (stringLength)
        {
            case 1: return IsInQuotationMarksHelper(sg, patternIndex, '\'');
            case 0: return false;
            default: return IsInQuotationMarksHelper(sg, patternIndex, '"');
        }
    }

    private void IsScriptinShader(string fp, Dictionary<string, string> Shaders, Dictionary<string, string[]> SC, string[] allShaderInclude, List<string> allfilesinasset)
    {
        string pathcontentext = File.ReadAllText(fp);
        string pathcontentextexp = Regex.Replace(pathcontentext, withoutnote, string.Empty, RegexOptions.Multiline);



        List<string> includestrings = ShaderScriptInclude("#include", pathcontentextexp, '"', '"');
        int mic = includestrings.Count;



        List<string> usepasstrings = ShaderScriptInclude("UsePass", pathcontentextexp, '"', '"');
        int muc = usepasstrings.Count;
        if (mic > 0)
        {
            string pathcontentextOmit = pathcontentext;
            bool IspathcontentextChange = false;
            for (int i = 0; i < allShaderInclude.Length; i++)
            {
                string micpath = allShaderInclude[i].Replace("\\", stringslash);
                string pathname = Path.GetFileName(micpath);
                for (int j = 0; j < mic; j++)
                {
                    string result = includestrings[j];
                    string specificResult = result;
                    for (int k = result.Length - 1; k >= 0; k--)
                    {
                        if (result[k] == '/')
                        {
                            result = result.Substring(k + 1);
                            break;
                        }
                    }
                    if (result == pathname && !aSETnodes.ContainsKey(micpath + stringspace + ASWFolderNames[3]))
                    {
                        ListClassified(micpath, false, string.Empty, fp, Shaders, SC, allShaderInclude, allfilesinasset);
                        IsScriptinShader(micpath, Shaders, SC, allShaderInclude, allfilesinasset);

                        if (specificResult == micpath)
                        {
                            pathcontentextOmit = pathcontentextOmit.Replace(specificResult, result);
                            IspathcontentextChange = true;
                        }
                    }
                }
            }
            if (IspathcontentextChange)
            {
                shaderincludes.Add(fp, new ShaderIncludeON(pathcontentext, pathcontentextOmit, string.Empty));

            }
        }
        if (muc > 0)
        {
            foreach (string shaderpath in Shaders.Keys)
            {
                string shadername = Shaders[shaderpath];
                for (int j = 0; j < muc; j++)
                {

                    string result = usepasstrings[j];
                    for (int k = result.Length - 1; k >= 0; k--)
                    {
                        if (result[k] == '/')
                        {
                            result = result.Substring(0, k);
                            break;
                        }
                    }
                    if (shadername == result && !aSETnodes.ContainsKey(shaderpath + stringspace + ASWFolderNames[3]))
                    {
                        ListClassified(shaderpath, false, string.Empty, fp, Shaders, SC, allShaderInclude, allfilesinasset);
                        IsScriptinShader(shaderpath, Shaders, SC, allShaderInclude, allfilesinasset);
                    }
                }
            }
        }

    }

    private void IsScriptinScript(string fp, Dictionary<string, string> allshaders, Dictionary<string, string[]> SC, string[] CgincandHlsl, List<string> allfilesinasset)
    {
        string pathcontentext = File.ReadAllText(fp);
        string pathcontentextexp = Regex.Replace(pathcontentext, withoutnote, string.Empty, RegexOptions.Multiline);


        foreach (string cspath in SC.Keys)       //通过已存的脚本类查找引用
        {
            string[] scvalues = SC[cspath];
            for (int i = 0; i < scvalues.Length; i++)
            {
                string classname = scvalues[i];
                string pa = @"\b" + classname + @"\b";
                Match mhpp = Regex.Match(pathcontentextexp, pa);
                bool Isscript = mhpp.Success && !IsInQuotationMarks(pathcontentextexp, mhpp.Index, classname.Length);
                if (Isscript && !aSETnodes.ContainsKey(cspath + stringspace + ASWFolderNames[5]))
                {
                    ListClassified(cspath, false, fp, string.Empty, allshaders, SC, CgincandHlsl, allfilesinasset);
                    IsScriptinScript(cspath, allshaders, SC, CgincandHlsl, allfilesinasset);
                }
            }
        }

        List<string> shaderfindstrings = ShaderScriptInclude("Shader.Find", pathcontentextexp, '(', ')');
        int matchesShaderFindC = shaderfindstrings.Count;
        if (matchesShaderFindC > 0)
        {
            foreach (string shaderpath in allshaders.Keys)
            {
                string shadername = allshaders[shaderpath];
                for (int k = 0; k < matchesShaderFindC; k++)
                {

                    string match = shaderfindstrings[k];
                    string matchnospace = match.Trim();
                    int p = 0;
                    for (; p < matchnospace.Length; p++)
                    {
                        if (matchnospace[p] == '"')
                        {
                            break;
                        }
                    }
                    if (p < matchnospace.Length)

                    {
                        string matchtemp = Clampstring(0, matchnospace.Length, matchnospace, '"', '"', true);
                        if (matchtemp == shadername && !aSETnodes.ContainsKey(shaderpath + stringspace + ASWFolderNames[3]))
                        {
                            ListClassified(shaderpath, false, fp, string.Empty, allshaders, SC, CgincandHlsl, allfilesinasset);
                        }
                    }
                    else
                    {

                        string pa = @"\b" + matchnospace + @"\b";
                        MatchCollection Isshaderfindscript = Regex.Matches(pathcontentextexp, pa, RegexOptions.Multiline);
                        for (int i = 0; i < Isshaderfindscript.Count; i++)
                        {
                            int paindex = Isshaderfindscript[i].Index;
                            if (!IsInQuotationMarks(pathcontentextexp, paindex, matchnospace.Length))
                            {
                                string matchtemp = Clampstring(paindex, matchnospace.Length, matchnospace, '"', '"', false);
                                if (matchtemp == shadername && !aSETnodes.ContainsKey(shaderpath + stringspace + ASWFolderNames[3]))
                                {
                                    ListClassified(shaderpath, false, fp, string.Empty, allshaders, SC, CgincandHlsl, allfilesinasset);
                                }
                            }
                        }
                    }
                }
            }
        }

        //如果cs里有路径引用，例如本脚本下的GUISkin。要求路径不能拆开来写，必须写完整，且为了节省我这边代码的计算，请直接写在下面三种函数内，而不是缓存再写在函数内，例如string directoryGUISkin = "Assets/Editor/AssetsSort/Icons/GUISkins/ASETSkin.guiskin";   AssetDatabase.LoadAssetAtPath(directoryGUISkin)是不可以的
        //具体：https://blog.csdn.net/weixin_43908355/article/details/115211590 
        //如果能公开，最好能公开，而不是在脚本内采用这种方式读取资源
        string miancited = "AssetDatabase.LoadAssetAtPath";
        string cited = @"\b" + miancited + @"\b";
        MatchCollection cited2 = Regex.Matches(pathcontentextexp, cited, RegexOptions.Multiline);
        for (int i = 0; i < cited2.Count; i++)
        {
            int cited2a = cited2[i].Index;
            if (!IsInQuotationMarks(pathcontentextexp, cited2a, miancited.Length))
            {
                Detectcsother(pathcontentextexp, cited2a, allshaders, SC, CgincandHlsl, allfilesinasset);
            }
        }
        string miancited2 = "Resources.LoadAssetAtPath";
        string cited3 = @"\b" + miancited2 + @"\b";
        MatchCollection cited4 = Regex.Matches(pathcontentextexp, cited3, RegexOptions.Multiline);
        for (int i = 0; i < cited4.Count; i++)
        {
            int cited4a = cited4[i].Index;
            if (!IsInQuotationMarks(pathcontentextexp, cited4a, miancited2.Length))
            {
                Detectcsother(pathcontentextexp, cited4a, allshaders, SC, CgincandHlsl, allfilesinasset);
            }
        }
        if (fp.StartsWith("Assets/Resources"))
        {
            string miancited3 = "Resource.Load";
            string cited5 = @"\b" + miancited3 + @"\b";
            MatchCollection cited6 = Regex.Matches(pathcontentextexp, cited5, RegexOptions.Multiline);
            for (int i = 0; i < cited6.Count; i++)
            {
                int cited6a = cited6[i].Index;
                if (!IsInQuotationMarks(pathcontentextexp, cited6a, miancited3.Length))
                {
                    Detectcsother(pathcontentextexp, cited6a, allshaders, SC, CgincandHlsl, allfilesinasset);
                }
            }
        }
    }

    // private void ClearConsole()
    // {
    //     Type log = typeof(EditorWindow).Assembly.GetType("UnityEditor.LogEntries");
    //     MethodInfo clearMethod = log.GetMethod("Clear");//调用控制台console
    //     clearMethod.Invoke(null, null);
    // }
    // private void Getstringprintstring()
    // {
    //     Type _logEntryType = Type.GetType("UnityEditor.LogEntry,UnityEditor");
    //     if (_logEntryType != null)
    //     {
    //         FieldInfo _conditionField = _logEntryType.GetField("message", BindingFlags.Public | BindingFlags.Instance);
    //         Type _LogEntriesType = Type.GetType("UnityEditor.LogEntries,UnityEditor");
    //         if (_LogEntriesType != null)
    //         {
    //             MethodInfo _GetEntryInternalMethod = _LogEntriesType.GetMethod("GetEntryInternal", BindingFlags.Static | BindingFlags.Public);
    //             object logEntry = Activator.CreateInstance(_logEntryType);
    //             object result = _GetEntryInternalMethod.Invoke(null, new object[] { 0, logEntry });
    //             if (bool.Parse(result.ToString()))
    //             {
    //                 string consolerealstring = _conditionField.GetValue(logEntry).ToString();
    //                 int debuglogindex = consolerealstring.IndexOf("\n");
    //                 consolerealstring = consolerealstring.Substring(0, debuglogindex);
    //                 ClearConsole();
    //                 UnityEngine.Debug.Log(consolerealstring);
    //             }
    //         }
    //     }
    // }
    private void Detectcsother(string pathcontentextexp, int kouhaoindex, Dictionary<string, string> allshaders, Dictionary<string, string[]> SC, string[] CgincandHlsl, List<string> allfilesinasset)
    {
        int firstfenhao = pathcontentextexp.IndexOf(";", kouhaoindex);
        string subpa = pathcontentextexp.Substring(kouhaoindex, firstfenhao - kouhaoindex);
        int shuangyinhaoleft = subpa.IndexOf('"');
        if (shuangyinhaoleft > -1)      //应对直接是路径字符串的
        {
            subpa = subpa.Substring(shuangyinhaoleft + 1);
            int shuangyinhaoleftright = subpa.IndexOf('"');
            if (shuangyinhaoleftright > -1)
            {
                subpa = subpa.Substring(0, shuangyinhaoleftright);
                ListClassified(subpa, false, string.Empty, string.Empty, allshaders, SC, CgincandHlsl, allfilesinasset);
            }
        }
        // else    //非路径字符串（使用声明存放的）
        // {
        //     int kuohaoleft = subpa.IndexOf("(");
        //     if (kuohaoleft > -1)
        //     {
        //         int douhaoright = subpa.IndexOf(",");//应对AssetDatabase.LoadAssetAtPath(XXX, typeof(Material)) as Material;这种
        //         if (douhaoright < 0)         ////应对AssetDatabase.LoadAssetAtPath<Material>(XXX);这种
        //         {
        //             douhaoright = subpa.IndexOf(")");
        //         }
        //         subpa = subpa.Substring(kuohaoleft + 1, douhaoright - kuohaoleft - 1);
        //         UnityEngine.Debug.Log(subpa);
        //         Getstringprintstring();
        //     }
        // }
    }
    private int ASETnodeallcount = 0;       //所有所选以及依赖文件的总数量
    private class ASETnode
    {
        public int asetindex;       //在该种类下的索引数
        public bool outputListIsSelected;       //是否选中
        public bool ListIsSelected;     //是否是鼠标选中的，不是依赖的文件
        public bool ListMouseClickIsSelected;       //是否是高亮选中
        public int SearchListindex;     //搜索状态下文件的搜索索引数
        public Rect ListRectPos;    //节点的Rect
        public Rect outerclickwhiteboxgrid;     //选择勾外面那层白框
        public List<string> ListDenpend;    //依赖文件集合
        public ASETnode(int A1, bool B1, bool C1, bool D1, int E1, Rect F1, Rect G1, List<string> H1)
        {
            asetindex = A1;
            outputListIsSelected = B1;
            ListIsSelected = C1;
            ListMouseClickIsSelected = D1;
            SearchListindex = E1;
            ListRectPos = F1;
            outerclickwhiteboxgrid = G1;
            ListDenpend = H1;
        }
    }

    private static readonly string stringspace = " ";
    private static readonly string stringslash = "/";
    private Dictionary<string, ASETnode> aSETnodes = new Dictionary<string, ASETnode>();
    private void Asetnodexist(string selepathname, string typename, bool isdepenfilesadd, string csparent, string shaparent, Dictionary<string, string> Shadernames, Dictionary<string, string[]> Scriptclassnames, string[] CgincandHlsl, List<string> allfilesinasset)
    {
        string asetkey = selepathname + stringspace + typename;     //key包含path——空格——类型
        if (!aSETnodes.ContainsKey(asetkey))
        {
            List<string> ldenpendsList = new List<string>();
            int thistypecount = 0;
            foreach (string j in aSETnodes.Keys)
            {
                string stringspacetypename = stringspace + typename;       //避免判断Shaders和ComputeShaders相同
                if (IsSuff(j, stringspacetypename))
                {
                    thistypecount++;
                }
            }
            ASETnode newase = new ASETnode(thistypecount, typename != ASWFolderNames[5], isdepenfilesadd, false, 0, new Rect(0, 0, 1, 1), new Rect(0, 0, 1, 1), ldenpendsList);
            // ASETnode newase = new ASETnode
            // {
            //     asetindex = thistypecount,
            //     ListIsSelected = isdepenfilesadd,
            //     ListMouseClickIsSelected = false,
            //     SearchListindex = 0,
            //     ListRectPos = new Rect(0, 0, 1, 1),
            //     outerclickwhiteboxgrid = new Rect(0, 0, 1, 1),
            //     ListDenpend = ldenpendsList,
            //     outputListIsSelected = typename != ASWFolderNames[5]
            // };
            aSETnodes.Add(asetkey, newase);
            ASETnodeallcount++;

            string[] ldenpends = AssetDatabase.GetDependencies(selepathname, false);        //用false是为了避免越级连线

            for (int i = 0; i < ldenpends.Length; i++)
            {
                string filePath = ldenpends[i];
                // if (!filePath.StartsWith("Packages/"))
                if (filePath.StartsWith(ASWFolderNames[21] + stringslash))
                {
                    ldenpendsList.Add(filePath + stringspace + ListClassified2(filePath));
                    ListClassified(filePath, false, string.Empty, string.Empty, Shadernames, Scriptclassnames, CgincandHlsl, allfilesinasset);
                    FindcsAndshader(filePath, Shadernames, Scriptclassnames, CgincandHlsl, allfilesinasset);
                }
            }
            aSETnodes[asetkey].ListDenpend = ldenpendsList;
            FindcsAndshader(selepathname, Shadernames, Scriptclassnames, CgincandHlsl, allfilesinasset);
        }
        if (csparent != string.Empty)
        {
            aSETnodes[csparent + stringspace + ASWFolderNames[5]].ListDenpend.Add(asetkey);
        }
        if (shaparent != string.Empty)
        {
            aSETnodes[shaparent + stringspace + ASWFolderNames[3]].ListDenpend.Add(asetkey);
        }
    }
    private void ListClassified(string selepathname, bool isdepenfilesadd, string csparent, string shaderparent, Dictionary<string, string> Shadernames, Dictionary<string, string[]> Scriptclassnames, string[] CgincandHlsl, List<string> allfilesinasset)
    {
        bool Iseei = IconShowType(selepathname) != null;
        switch (selepathname)
        {
            case string _ when Iseei && IconShowType(selepathname).Name == "Material": { Asetnodexist(selepathname, ASWFolderNames[2], isdepenfilesadd, csparent, shaderparent, Shadernames, Scriptclassnames, CgincandHlsl, allfilesinasset); break; }
            case string _ when IsSuff(selepathname, ".shader") || IsSuff(selepathname, ".shadergraph") || IsSuff(selepathname, ".cginc") || IsSuff(selepathname, ".hlsl"): { Asetnodexist(selepathname, ASWFolderNames[3], isdepenfilesadd, csparent, shaderparent, Shadernames, Scriptclassnames, CgincandHlsl, allfilesinasset); break; }
            case string _ when (Iseei && (IconShowType(selepathname).Name == "Texture2D" || IconShowType(selepathname).Name == "Texture3D" || IconShowType(selepathname).Name == "Cubemap")) || IsSuff(selepathname, ".renderTexture"): { Asetnodexist(selepathname, ASWFolderNames[4], isdepenfilesadd, csparent, shaderparent, Shadernames, Scriptclassnames, CgincandHlsl, allfilesinasset); break; }
            case string _ when IsSuff(selepathname, ".prefab"): { Asetnodexist(selepathname, ASWFolderNames[1], isdepenfilesadd, csparent, shaderparent, Shadernames, Scriptclassnames, CgincandHlsl, allfilesinasset); break; }
            case string _ when Iseei && IconShowType(selepathname).Name == "GameObject": { Asetnodexist(selepathname, ASWFolderNames[6], isdepenfilesadd, csparent, shaderparent, Shadernames, Scriptclassnames, CgincandHlsl, allfilesinasset); break; }
            case string _ when IsSuff(selepathname, ".anim"): { Asetnodexist(selepathname, ASWFolderNames[8], isdepenfilesadd, csparent, shaderparent, Shadernames, Scriptclassnames, CgincandHlsl, allfilesinasset); break; }
            case string _ when IsSuff(selepathname, ".controller") || IsSuff(selepathname, ".overrideController"): { Asetnodexist(selepathname, ASWFolderNames[7], isdepenfilesadd, csparent, shaderparent, Shadernames, Scriptclassnames, CgincandHlsl, allfilesinasset); break; }
            case string _ when IsSuff(selepathname, ".cs"): { Asetnodexist(selepathname, ASWFolderNames[5], isdepenfilesadd, csparent, shaderparent, Shadernames, Scriptclassnames, CgincandHlsl, allfilesinasset); break; }
            case string _ when IsSuff(selepathname, ".unity"): { Asetnodexist(selepathname, ASWFolderNames[0], isdepenfilesadd, csparent, shaderparent, Shadernames, Scriptclassnames, CgincandHlsl, allfilesinasset); break; }
            case string _ when IsSuff(selepathname, ".playable"): { Asetnodexist(selepathname, ASWFolderNames[9], isdepenfilesadd, csparent, shaderparent, Shadernames, Scriptclassnames, CgincandHlsl, allfilesinasset); break; }
            case string _ when IsSuff(selepathname, ".guiskin"): { Asetnodexist(selepathname, ASWFolderNames[10], isdepenfilesadd, csparent, shaderparent, Shadernames, Scriptclassnames, CgincandHlsl, allfilesinasset); break; }
            case string _ when Iseei && (IconShowType(selepathname).Name == "Mesh"): { Asetnodexist(selepathname, ASWFolderNames[11], isdepenfilesadd, csparent, shaderparent, Shadernames, Scriptclassnames, CgincandHlsl, allfilesinasset); break; }
            case string _ when Iseei && (IconShowType(selepathname).Name == "Sprite" || IconShowType(selepathname).Name == "SpriteAtlas"): { Asetnodexist(selepathname, ASWFolderNames[12], isdepenfilesadd, csparent, shaderparent, Shadernames, Scriptclassnames, CgincandHlsl, allfilesinasset); break; }
            case string _ when Iseei && (IconShowType(selepathname).Name == "TerrainData" || IconShowType(selepathname).Name == "TerrainLayer"): { Asetnodexist(selepathname, ASWFolderNames[13], isdepenfilesadd, csparent, shaderparent, Shadernames, Scriptclassnames, CgincandHlsl, allfilesinasset); break; }
            case string _ when Iseei && IconShowType(selepathname).Name == "AudioClip" || IsSuff(selepathname, ".mixer"): { Asetnodexist(selepathname, ASWFolderNames[14], isdepenfilesadd, csparent, shaderparent, Shadernames, Scriptclassnames, CgincandHlsl, allfilesinasset); break; }
            case string _ when LowUpTrans(selepathname, ".mp4") || LowUpTrans(selepathname, ".mov"): { Asetnodexist(selepathname, ASWFolderNames[15], isdepenfilesadd, csparent, shaderparent, Shadernames, Scriptclassnames, CgincandHlsl, allfilesinasset); break; }
            case string _ when IsSuff(selepathname, ".physicMaterial"): { Asetnodexist(selepathname, ASWFolderNames[16], isdepenfilesadd, csparent, shaderparent, Shadernames, Scriptclassnames, CgincandHlsl, allfilesinasset); break; }
            case string _ when Iseei && (IconShowType(selepathname).Name == "LightingDataAsset" || IconShowType(selepathname).Name == "LightingSettings"): { Asetnodexist(selepathname, ASWFolderNames[17], isdepenfilesadd, csparent, shaderparent, Shadernames, Scriptclassnames, CgincandHlsl, allfilesinasset); break; }
            case string _ when IsSuff(selepathname, ".vfx"): { Asetnodexist(selepathname, ASWFolderNames[18], isdepenfilesadd, csparent, shaderparent, Shadernames, Scriptclassnames, CgincandHlsl, allfilesinasset); break; }
            case string _ when IsSuff(selepathname, ".compute"): { Asetnodexist(selepathname, ASWFolderNames[19], isdepenfilesadd, csparent, shaderparent, Shadernames, Scriptclassnames, CgincandHlsl, allfilesinasset); break; }
            case string _ when LowUpTrans(selepathname, ".ttf"): { Asetnodexist(selepathname, ASWFolderNames[20], isdepenfilesadd, csparent, shaderparent, Shadernames, Scriptclassnames, CgincandHlsl, allfilesinasset); break; }
            case string _ when IsSuff(selepathname, ".asset"): { Asetnodexist(selepathname, ASWFolderNames[21], isdepenfilesadd, csparent, shaderparent, Shadernames, Scriptclassnames, CgincandHlsl, allfilesinasset); break; }
            default: { Asetnodexist(selepathname, ASWFolderNames[22], isdepenfilesadd, csparent, shaderparent, Shadernames, Scriptclassnames, CgincandHlsl, allfilesinasset); break; }
        }
    }
    private string ListClassified2(string selepathname)     //根据路径判断属于哪个种类
    {

        bool Iseei = IconShowType(selepathname) != null;
        switch (selepathname)
        {
            case string _ when Iseei && IconShowType(selepathname).Name == "Material": { return ASWFolderNames[2]; }
            case string _ when IsSuff(selepathname, ".shader") || IsSuff(selepathname, ".shadergraph") || IsSuff(selepathname, ".cginc") || IsSuff(selepathname, ".hlsl"): { return ASWFolderNames[3]; }
            case string _ when (Iseei && (IconShowType(selepathname).Name == "Texture2D" || IconShowType(selepathname).Name == "Texture3D" || IconShowType(selepathname).Name == "Cubemap")) || IsSuff(selepathname, ".renderTexture"): { return ASWFolderNames[4]; }
            case string _ when IsSuff(selepathname, ".prefab"): { return ASWFolderNames[1]; }
            case string _ when Iseei && IconShowType(selepathname).Name == "GameObject": { return ASWFolderNames[6]; }
            case string _ when IsSuff(selepathname, ".anim"): { return ASWFolderNames[8]; }
            case string _ when IsSuff(selepathname, ".controller") || IsSuff(selepathname, ".overrideController"): { return ASWFolderNames[7]; }
            case string _ when IsSuff(selepathname, ".cs"): { return ASWFolderNames[5]; }
            case string _ when IsSuff(selepathname, ".unity"): { return ASWFolderNames[0]; }
            case string _ when IsSuff(selepathname, ".playable"): { return ASWFolderNames[9]; }
            case string _ when IsSuff(selepathname, ".guiskin"): { return ASWFolderNames[10]; }
            case string _ when Iseei && (IconShowType(selepathname).Name == "Mesh"): { return ASWFolderNames[11]; }
            case string _ when Iseei && (IconShowType(selepathname).Name == "Sprite" || IconShowType(selepathname).Name == "SpriteAtlas"): { return ASWFolderNames[12]; }
            case string _ when Iseei && (IconShowType(selepathname).Name == "TerrainData" || IconShowType(selepathname).Name == "TerrainLayer"): { return ASWFolderNames[13]; }
            case string _ when Iseei && IconShowType(selepathname).Name == "AudioClip" || IsSuff(selepathname, ".mixer"): { return ASWFolderNames[14]; }
            case string _ when LowUpTrans(selepathname, ".mp4") || LowUpTrans(selepathname, ".mov"): { return ASWFolderNames[15]; }
            case string _ when IsSuff(selepathname, ".physicMaterial"): { return ASWFolderNames[16]; }
            case string _ when Iseei && (IconShowType(selepathname).Name == "LightingDataAsset" || IconShowType(selepathname).Name == "LightingSettings"): { return ASWFolderNames[17]; }
            case string _ when IsSuff(selepathname, ".vfx"): { return ASWFolderNames[18]; }
            case string _ when IsSuff(selepathname, ".compute"): { return ASWFolderNames[19]; }
            case string _ when LowUpTrans(selepathname, ".ttf"): { return ASWFolderNames[20]; }
            case string _ when IsSuff(selepathname, ".asset"): { return ASWFolderNames[21]; }
            default: { return ASWFolderNames[22]; }
        }
    }
    private int[] intypecount;      //记录每个种类的个数
    private List<string> SortTypeNode(string[] orderarray, List<string> targetArray)        //根据一个string[]的顺序来对targetArray排序
    {
        Dictionary<string, int> orderDict = new Dictionary<string, int>();
        for (int i = 0; i < orderarray.Length; i++)
        {
            orderDict[orderarray[i]] = i; // 将元素及其索引存入字典
        }
        List<string> sortedTargetList = new List<string>();
        foreach (string j in targetArray)
        {
            if (orderDict.ContainsKey(j)) // 确保 j 在 orderDict 中
            {
                sortedTargetList.Add(j);
            }
        }
        sortedTargetList.Sort((x, y) => orderDict[x].CompareTo(orderDict[y]));
        return sortedTargetList;
    }
    private bool[] SearchSelectOne;
    private float[] SearchSelectOneSeqtranstemp;
    private List<string> currentSelectedIndex = new List<string>();
    private int shiftcontinue = 0;
    private int shiftcontinue2 = 0;
    private List<string> UselessMatexModel = new List<string>();     //装材质球内无用贴图，粒子内无用材质球，无用模型的路径
    private void Fortexuesless(string asetkey, ref List<string> singlelayerdepend)
    {
        ASETnode asetnodeval = aSETnodes[asetkey];
        for (int k = 0; k < asetnodeval.ListDenpend.Count; k++)
        {
            string nowdepentypename1 = asetnodeval.ListDenpend[k];
            if (UselessMatexModel.Contains(nowdepentypename1))
            {
                UselessMatexModel.Remove(nowdepentypename1);
                if (!singlelayerdepend.Contains(nowdepentypename1))
                {
                    singlelayerdepend.Add(nowdepentypename1);
                }
                Fortexuesless(nowdepentypename1, ref singlelayerdepend);
            }
        }
    }
    private void Getuselestex(string asetkey, string nowpathname1, string nowtypename1, ref List<string> singlelayerdepend)     //挑出无用资源
    {
        // ASETnode asetnodeval = aSETnodes[asetkey];
        if (nowtypename1 == ASWFolderNames[2])      //材质球
        {
            if (singlelayerdepend.Contains(asetkey) && UselessMatexModel.Contains(asetkey))
            {
                UselessMatexModel.Remove(asetkey);
            }

            Material matemp = AssetDatabase.LoadAssetAtPath<Material>(nowpathname1);
            // for (int k = 0; k < asetnodeval.ListDenpend.Count; k++)
            // {
            //     string nowdepentypename1 = asetnodeval.ListDenpend[k];
            //     string nowdepentype = nowdepentypename1.Substring(nowdepentypename1.LastIndexOf(stringspace) + 1);
            //     if (nowdepentype == ASWFolderNames[4] && !UselessMatexModel.Contains(nowdepentypename1))
            //     {
            //         UselessMatexModel.Add(nowdepentypename1); UnityEngine.Debug.Log(nowdepentypename1);
            //     }
            // }
            string[] prefabdepend = AssetDatabase.GetDependencies(nowpathname1, true);
            for (int q = 0; q < prefabdepend.Length; q++)
            {
                string nowdependname1 = prefabdepend[q];
                if (nowdependname1.StartsWith(ASWFolderNames[21]))
                {
                    string type1 = ListClassified2(nowdependname1);
                    if (type1 == ASWFolderNames[4])
                    {
                        string texasetkey = nowdependname1 + stringspace + type1;
                        if (!singlelayerdepend.Contains(texasetkey) && !UselessMatexModel.Contains(texasetkey))
                        {
                            UselessMatexModel.Add(texasetkey);
                        }
                    }
                }
            }
            Shader matempshader = matemp.shader;
            int matempshaderprocount = UnityEditor.ShaderUtil.GetPropertyCount(matempshader);//获得Shader声明的变量的数量
            for (int z = 0; z < matempshaderprocount; z++)
            {
                UnityEditor.ShaderUtil.ShaderPropertyType matempshaderproType = UnityEditor.ShaderUtil.GetPropertyType(matempshader, z);    //获取变量的种类
                if (matempshaderproType == UnityEditor.ShaderUtil.ShaderPropertyType.TexEnv)    //变量是否属于贴图种类
                {
                    string matempshaderpro_name = UnityEditor.ShaderUtil.GetPropertyName(matempshader, z);      //获取到贴图变量的属性名称
                    Texture matemptex = matemp.GetTexture(matempshaderpro_name);

                    if (matemptex != null)
                    {
                        string textureGUID = AssetDatabase.GetAssetPath(matemptex);
                        string texturePathNtype = textureGUID + stringspace + ASWFolderNames[4];
                        if (UselessMatexModel.Contains(texturePathNtype))
                        {
                            UselessMatexModel.Remove(texturePathNtype);
                            if (!singlelayerdepend.Contains(texturePathNtype))      //真的依赖文件需要保留
                            {
                                singlelayerdepend.Add(texturePathNtype);
                            }
                            Fortexuesless(texturePathNtype, ref singlelayerdepend);
                        }
                    }
                }
            }
        }
        else if (nowtypename1 == ASWFolderNames[1])     //预制体
        {
            GameObject gbtemp = AssetDatabase.LoadAssetAtPath<GameObject>(nowpathname1);

            // string[] prefabdepend = AssetDatabase.GetDependencies(nowpathname1, true);
            // for (int q = 0; q < prefabdepend.Length; q++)
            // {
            //     string nowdependname1 = prefabdepend[q];
            //     if (nowdependname1.StartsWith(ASWFolderNames[21]))
            //     {
            //         string type1 = ListClassified2(nowdependname1);
            //         if (type1 == ASWFolderNames[2] || type1 == ASWFolderNames[4] || type1 == ASWFolderNames[6])
            //         {
            //             UselessMatexModel.Add(nowdependname1 + stringspace + type1);
            //         }
            //     }
            // }
            // Uselessmatloopadd(asetnodeval, ASWFolderNames[2], ASWFolderNames[6]);

            SpriteRenderer[] gbtempsarraysr = gbtemp.GetComponentsInChildren<SpriteRenderer>();
            for (int j = 0; j < gbtempsarraysr.Length; j++)
            {
                SpriteRenderer psjm = gbtempsarraysr[j];
                /************如果是非粒子系统组件，且依赖文件中含有粒子组件中无用文件的，需要保留*********/
                string spriteMATGUID = AssetDatabase.GetAssetPath(psjm.sprite);
                string spritematPathNtype = spriteMATGUID + stringspace + ASWFolderNames[4];
                if (!singlelayerdepend.Contains(spritematPathNtype))
                {
                    singlelayerdepend.Add(spritematPathNtype);
                }
            }
            Image[] gbtempsarrayUI = gbtemp.GetComponentsInChildren<Image>();
            for (int j = 0; j < gbtempsarrayUI.Length; j++)
            {
                Image psjg = gbtempsarrayUI[j];
                /************如果是非粒子系统组件，且依赖文件中含有粒子组件中无用文件的，需要保留*********/
                string spriteMATGUID = AssetDatabase.GetAssetPath(psjg.sprite);
                string spritematPathNtype = spriteMATGUID + stringspace + ASWFolderNames[4];
                if (!singlelayerdepend.Contains(spritematPathNtype))
                {
                    singlelayerdepend.Add(spritematPathNtype);
                }
            }
            ParticleSystem[] gbtempsarray = gbtemp.GetComponentsInChildren<ParticleSystem>();
            for (int j = 0; j < gbtempsarray.Length; j++)
            {
                ParticleSystem psjg = gbtempsarray[j];
                ParticleSystemRenderer psjrender = psjg.GetComponent<ParticleSystemRenderer>();
                if (psjrender.renderMode == ParticleSystemRenderMode.Mesh)        //真的依赖文件需要保留
                {
                    Mesh[] rendermeshes = new Mesh[psjrender.meshCount];
                    psjrender.GetMeshes(rendermeshes);
                    for (int q = 0; q < rendermeshes.Length; q++)
                    {
                        Mesh rendermesh1 = rendermeshes[q];
                        string RendermeshGUID = AssetDatabase.GetAssetPath(rendermesh1);
                        if (RendermeshGUID.StartsWith(ASWFolderNames[21]))
                        {
                            string RendermeshPathNtype = RendermeshGUID + stringspace + ASWFolderNames[6];
                            if (!singlelayerdepend.Contains(RendermeshPathNtype))
                            {
                                singlelayerdepend.Add(RendermeshPathNtype);
                            }
                        }
                    }
                }
                else//模型模式
                {
                    Mesh[] rendermeshes = new Mesh[psjrender.meshCount];
                    psjrender.GetMeshes(rendermeshes);
                    for (int q = 0; q < rendermeshes.Length; q++)
                    {
                        Mesh rendermesh1 = rendermeshes[q];
                        string RendermeshGUID = AssetDatabase.GetAssetPath(rendermesh1);
                        if (RendermeshGUID.StartsWith(ASWFolderNames[21]))
                        {
                            string RendermeshPathNtype = RendermeshGUID + stringspace + ASWFolderNames[6];
                            // if (UselessMatexModel.Contains(RendermeshPathNtype))
                            // {
                            //     UselessMatexModel.Remove(RendermeshPathNtype);
                            // }
                            if (!UselessMatexModel.Contains(RendermeshPathNtype) && !singlelayerdepend.Contains(RendermeshPathNtype))
                            {
                                UselessMatexModel.Add(RendermeshPathNtype);
                            }
                        }

                    }
                    if (psjrender.renderMode == ParticleSystemRenderMode.None)            //主材质球
                    {
                        Material psjrmat = psjrender.sharedMaterial;
                        if (psjrmat != null)
                        {
                            string MATGUID = AssetDatabase.GetAssetPath(psjrmat);
                            if (MATGUID.StartsWith(ASWFolderNames[21]))
                            {
                                string matPathNtype = MATGUID + stringspace + ASWFolderNames[2];
                                // Material matemp = AssetDatabase.LoadAssetAtPath<Material>(MATGUID);
                                // Matuselesscore(matemp);
                                // if (UselessMatexModel.Contains(matPathNtype))
                                // {
                                //     UselessMatexModel.Remove(matPathNtype);
                                // }
                                if (!UselessMatexModel.Contains(matPathNtype) && !singlelayerdepend.Contains(matPathNtype))
                                {
                                    UselessMatexModel.Add(matPathNtype);
                                }
                            }
                        }
                    }
                    else     //真的依赖文件需要保留
                    {
                        Material psjrmat = psjrender.sharedMaterial;
                        if (psjrmat != null)
                        {
                            string MATGUID = AssetDatabase.GetAssetPath(psjrmat);
                            if (MATGUID.StartsWith(ASWFolderNames[21]))
                            {
                                string matPathNtype = MATGUID + stringspace + ASWFolderNames[2];
                                if (!singlelayerdepend.Contains(matPathNtype))
                                {
                                    singlelayerdepend.Add(matPathNtype);
                                }
                            }
                        }
                    }
                }
                ParticleSystem.TrailModule pstr = psjg.trails;       //拖尾材质球
                if (!pstr.enabled)
                {
                    Material pstrmat = psjrender.trailMaterial;
                    if (pstrmat != null)
                    {
                        string trailMATGUID = AssetDatabase.GetAssetPath(pstrmat);
                        if (trailMATGUID.StartsWith(ASWFolderNames[21]))
                        {
                            string trailmatPathNtype = trailMATGUID + stringspace + ASWFolderNames[2];
                            // Material matemp = AssetDatabase.LoadAssetAtPath<Material>(trailMATGUID);
                            // Matuselesscore(matemp);
                            // if (UselessMatexModel.Contains(trailmatPathNtype))
                            // {
                            //     UselessMatexModel.Remove(trailmatPathNtype);
                            // }

                            if (!UselessMatexModel.Contains(trailmatPathNtype) && !singlelayerdepend.Contains(trailmatPathNtype))
                            {
                                UselessMatexModel.Add(trailmatPathNtype);
                            }
                        }
                    }
                }
                else     //真的依赖文件需要保留
                {
                    Material pstrmat = psjrender.trailMaterial;
                    if (pstrmat != null)
                    {
                        string trailMATGUID = AssetDatabase.GetAssetPath(pstrmat);
                        if (trailMATGUID.StartsWith(ASWFolderNames[21]))
                        {
                            string trailmatPathNtype = trailMATGUID + stringspace + ASWFolderNames[2];
                            if (!singlelayerdepend.Contains(trailmatPathNtype))
                            {
                                singlelayerdepend.Add(trailmatPathNtype);
                            }
                        }
                    }
                }

                ParticleSystem.ShapeModule pstshape = psjg.shape;       //粒子发射形状
                if (!(pstshape.shapeType == ParticleSystemShapeType.Mesh || pstshape.shapeType == ParticleSystemShapeType.MeshRenderer || pstshape.shapeType == ParticleSystemShapeType.SkinnedMeshRenderer || pstshape.shapeType == ParticleSystemShapeType.Sprite || pstshape.shapeType == ParticleSystemShapeType.SpriteRenderer))
                {
                    if (pstshape.mesh != null)
                    {
                        string shapemeshMATGUID = AssetDatabase.GetAssetPath(pstshape.mesh);
                        if (shapemeshMATGUID.StartsWith(ASWFolderNames[21]))
                        {
                            string shapemeshmatPathNtype = shapemeshMATGUID + stringspace + ASWFolderNames[6];
                            // if (UselessMatexModel.Contains(shapemeshmatPathNtype))
                            // {
                            //     UselessMatexModel.Remove(shapemeshmatPathNtype);
                            // }
                            if (!UselessMatexModel.Contains(shapemeshmatPathNtype) && !singlelayerdepend.Contains(shapemeshmatPathNtype))
                            {
                                UselessMatexModel.Add(shapemeshmatPathNtype);
                            }
                        }

                    }
                    if (pstshape.sprite != null)
                    {
                        string shapespriteMATGUID = AssetDatabase.GetAssetPath(pstshape.sprite);
                        string shapespritematPathNtype = shapespriteMATGUID + stringspace + ASWFolderNames[4];
                        // if (UselessMatexModel.Contains(shapespritematPathNtype))
                        // {
                        //     UselessMatexModel.Remove(shapespritematPathNtype);
                        // }
                        if (!UselessMatexModel.Contains(shapespritematPathNtype) && !singlelayerdepend.Contains(shapespritematPathNtype))
                        {
                            UselessMatexModel.Add(shapespritematPathNtype);
                        }
                    }
                }
                else     //真的依赖文件需要保留
                {
                    if (pstshape.mesh != null)
                    {
                        string shapemeshMATGUID = AssetDatabase.GetAssetPath(pstshape.mesh);
                        if (shapemeshMATGUID.StartsWith(ASWFolderNames[21]))
                        {
                            string shapemeshmatPathNtype = shapemeshMATGUID + stringspace + ASWFolderNames[6];
                            if (!singlelayerdepend.Contains(shapemeshmatPathNtype))
                            {
                                singlelayerdepend.Add(shapemeshmatPathNtype);
                            }
                        }

                    }
                    if (pstshape.sprite != null)
                    {
                        string shapespriteMATGUID = AssetDatabase.GetAssetPath(pstshape.sprite);
                        string shapespritematPathNtype = shapespriteMATGUID + stringspace + ASWFolderNames[4];
                        if (!singlelayerdepend.Contains(shapespritematPathNtype))
                        {
                            singlelayerdepend.Add(shapespritematPathNtype);
                        }
                    }
                }
            }
        }
    }
    private bool iconisexist = true;
    public GUISkin GUISKINIcons;
    private void OnEnable()
    {
        /******************先保存********************/
        // EditorApplication.ExecuteMenuItem("File/Save Project");  //保存项目
        AssetDatabase.SaveAssets();     //保存项目

        EditorSceneManager.SaveOpenScenes();    //保存场景
        /*******************************************/


        /******************美化区*******************/
        iconisexist = GUISKINIcons == null || GUISKINIcons.box.normal.background == null && GUISKINIcons.label.normal.background == null && GUISKINIcons.customStyles[3].normal.background == null && GUISKINIcons.customStyles[3].onNormal.background == null;
        /******************************************/



        // bool firstcs = SrJFqU_AAyGB_m4_fj4D3_52a0G4A_72.shouldbe;
        // if ( firstcs )
        // {
        //     wnd.Close();
        //     return ;
        // }
        string[] guidShader = Directory.GetFiles(ASWFolderNames[21], "*.shader", SearchOption.AllDirectories);
        string[] cgincInAssets = Directory.GetFiles(ASWFolderNames[21], "*.cginc", SearchOption.AllDirectories);
        string[] hlslInAssets = Directory.GetFiles(ASWFolderNames[21], "*.hlsl", SearchOption.AllDirectories);
        int guidShaderL = guidShader.Length;
        int guidCgincL = cgincInAssets.Length;
        int guidHlslL = hlslInAssets.Length;
        int guidCgincNHlslL = guidCgincL + guidHlslL;
        int guidAllL = guidShaderL + guidCgincNHlslL;
        string[] guids = new string[guidAllL];
        string[] guidscgincNhlsl = new string[guidCgincNHlslL];
        cgincInAssets.CopyTo(guidscgincNhlsl, 0);
        hlslInAssets.CopyTo(guidscgincNhlsl, guidCgincL);
        guidShader.CopyTo(guids, 0);
        guidscgincNhlsl.CopyTo(guids, guidShaderL);
        bool Temp = false;
        if (SrJFqU_AAyGB_m4_fj4D3_52a0G4A_72.lastWriteTime.Length != guidAllL)
        {
            SrJFqU_AAyGB_m4_fj4D3_52a0G4A_72.DiffShaderLength(guids, guidAllL);
            Temp = true;
        }
        else
        {
            for (int i = 0; i < guidAllL; i++)
            {
                string guid = guids[i];
                DateTime lastModifiedTime = File.GetLastWriteTime(guid);
                if (lastModifiedTime > SrJFqU_AAyGB_m4_fj4D3_52a0G4A_72.lastWriteTime[i])
                {
                    Temp = true;
                    SrJFqU_AAyGB_m4_fj4D3_52a0G4A_72.lastWriteTime[i] = lastModifiedTime;
                }
            }
        }
        if (Temp)
        {
            SrJFqU_AAyGB_m4_fj4D3_52a0G4A_72.LASS(guidShader, guidShaderL, guidscgincNhlsl, guidCgincNHlslL);
        }


        aSETnodes = new Dictionary<string, ASETnode>();
        Dictionary<string, string> Shadernames = SrJFqU_AAyGB_m4_fj4D3_52a0G4A_72.shadernames;
        Dictionary<string, string[]> Scriptclassnames = SrJFqU_AAyGB_m4_fj4D3_52a0G4A_72.scriptclassnames;
        string[] CgincandHlsl = SrJFqU_AAyGB_m4_fj4D3_52a0G4A_72.cgincandhlsl;

        List<string> allfilesinasset = new List<string>();

        // var beginTime = System.DateTime.UtcNow.Ticks;
        // {
        // List<string> allfilesinasset1 = new List<string>();
        string[] allfilesinassetarray = Directory.GetFiles(ASWFolderNames[21], "*", SearchOption.AllDirectories);        //会包含一些unity不能识别的（windows的）文件，这里要注意一下，例如在编辑器内是.bundle文件，但在编辑器外是文件夹
        for (int qq = 0; qq < allfilesinassetarray.Length; qq++)
        {
            string allfilesinassetarrayqq = allfilesinassetarray[qq];
            if (!IsSuff(allfilesinassetarrayqq, Stringmeta))
            {
                string slashreplace = allfilesinassetarrayqq.Replace("\\", stringslash);
                allfilesinasset.Add(slashreplace);
            }
        }
        // string[] allAssetPaths = AssetDatabase.GetAllAssetPaths();       //比较麻烦
        // for (int qq = 0; qq < allAssetPaths.Length; qq++)
        // {
        //     string allAssetPathsqq = allAssetPaths[qq];
        //     if (allAssetPathsqq.StartsWith(ASWFolderNames[21] + stringslash) && File.Exists(allAssetPathsqq))
        //     {
        //         allfilesinasset.Add(allAssetPathsqq);
        //     }
        // }
        // string[] allAssetPaths = AssetDatabase.FindAssets("*", new[] { ASWFolderNames[21] });   //少一个StartsWith的判断条件
        // for (int qq = 0; qq < allAssetPaths.Length; qq++)
        // {
        //     string allAssetPathsqqGUID = allAssetPaths[qq];
        //     string allAssetPathsqq = AssetDatabase.GUIDToAssetPath(allAssetPathsqqGUID);
        //     if (File.Exists(allAssetPathsqq))
        //     {
        //         allfilesinasset.Add(allAssetPathsqq);
        //     }
        // }
        // for (int zz = 0; zz < allfilesinasset1.Count; zz++)
        // {
        //     UnityEngine.Debug.Log(allfilesinasset.Contains(allfilesinasset1[zz]));
        //     UnityEngine.Debug.Log(allfilesinasset1[zz]);
        // }
        // }
        // var endTime = System.DateTime.UtcNow.Ticks;
        // var deltaTime = endTime - beginTime;
        // UnityEngine.Debug.Log($"{deltaTime / 10000.0}ms");
        // UnityEngine.Debug.Log(allfilesinasset.Count);

        UnityEngine.Object[] selectedObjects = Selection.GetFiltered<UnityEngine.Object>(SelectionMode.Assets);
        if (selectedObjects.Length == 0)
        {
            selectedObjects = Selection.objects;
        }

        for (int i = 0; i < selectedObjects.Length; i++)
        {
            string directoryPath = AssetDatabase.GetAssetPath(selectedObjects[i]);
            if (directoryPath.StartsWith(ASWFolderNames[21] + stringslash))
            {
                if (Directory.Exists(directoryPath))
                {
                    string[] allFilesInDir = Directory.GetFiles(directoryPath, "*", SearchOption.AllDirectories);     //会包含一些unity不能识别的（windows的）文件，这里要注意一下，例如在编辑器内是.bundle文件，但在编辑器外是文件夹
                    for (int j = 0; j < allFilesInDir.Length; j++)
                    {
                        string allFilesInDirj = allFilesInDir[j];
                        if (allFilesInDirj != string.Empty && !IsSuff(allFilesInDirj, Stringmeta))
                        {
                            string nowpathname = allFilesInDirj.Replace("\\", stringslash);
                            ListClassified(nowpathname, true, string.Empty, string.Empty, Shadernames, Scriptclassnames, CgincandHlsl, allfilesinasset);
                        }
                    }
                }
                else
                {
                    if (directoryPath != string.Empty)
                    {
                        ListClassified(directoryPath, true, string.Empty, string.Empty, Shadernames, Scriptclassnames, CgincandHlsl, allfilesinasset);
                    }
                }
            }
        }
        /*****************本来因为有些文件在unity编辑器中是文件，但是在window内是文件夹，而Directory.Exists是C#windows层面的检测，会把他识别成文件夹，例如.bundle文件****************************/
        /*****************但是后面的代码中涉及到很多Directory.Exists，所以还是舍弃了这段新的代码****************************/
        // for (int i = 0; i < selectedObjects.Length; i++)
        // {
        //     string directoryPath = AssetDatabase.GetAssetPath(selectedObjects[i]);
        //     if (directoryPath.StartsWith(ASWFolderNames[21] + stringslash))
        //     {
        //         int directoryPathslashindex = directoryPath.LastIndexOf(stringslash);
        //         int directoryPathdotindex = directoryPath.LastIndexOf(".");
        //         if (directoryPathdotindex == -1 || directoryPathdotindex < directoryPathslashindex)
        //         // if (Directory.Exists(directoryPath))
        //         {
        //             string[] allFilesInDir = AssetDatabase.FindAssets("*", new[] { directoryPath });
        //             for (int j = 0; j < allFilesInDir.Length; j++)
        //             {
        //                 string allFilesInDirjGUID = allFilesInDir[j];
        //                 string allFilesInDirj = AssetDatabase.GUIDToAssetPath(allFilesInDirjGUID);
        //                 if (File.Exists(allFilesInDirj))
        //                 {
        //                     ListClassified(allFilesInDirj, true, string.Empty, string.Empty, Shadernames, Scriptclassnames, CgincandHlsl, allfilesinasset);
        //                 }
        //             }
        //         }
        //         else
        //         {
        //             ListClassified(directoryPath, true, string.Empty, string.Empty, Shadernames, Scriptclassnames, CgincandHlsl, allfilesinasset);
        //         }
        //     }
        // }
        /*********************************************/


        if (ASETnodeallcount == 0)
        {
            wnd.Close();
            return;
        }



        List<string> singlelayerdepend = new List<string>();       //记录预制体中非粒子的依赖
        List<string> selectingtypes = new List<string>();       //记录aSETnodes每一个元素的种类，存放依赖文件
        foreach (string q in aSETnodes.Keys)
        {
            string asetnodepath = q.Substring(0, q.LastIndexOf(stringspace));
            string asetnodetype = q.Substring(q.LastIndexOf(stringspace) + 1);
            if (!selectingtypes.Contains(asetnodetype))
            {
                selectingtypes.Add(asetnodetype);
            }

            Getuselestex(q, asetnodepath, asetnodetype, ref singlelayerdepend);         //挑出无用资源

        }
        foreach (string n in UselessMatexModel)
        {
            aSETnodes[n].outputListIsSelected = false;
        }
        List<string> sortedTargetList = new List<string>();     //存放所有所选文件
        for (int i = 0; i < selectedObjects.Length; i++)
        {
            string directoryPath = AssetDatabase.GetAssetPath(selectedObjects[i]);
            if (Directory.Exists(directoryPath))
            {
                string[] allFilesInDir = Directory.GetFiles(directoryPath, "*", SearchOption.AllDirectories);

                for (int j = 0; j < allFilesInDir.Length; j++)
                {
                    string allFilesInDirj = allFilesInDir[j];
                    if (allFilesInDirj != string.Empty && !IsSuff(allFilesInDirj, Stringmeta))
                    {
                        string nowpathname = allFilesInDirj.Replace("\\", stringslash);
                        foreach (string q in aSETnodes.Keys)
                        {
                            if (q.StartsWith(nowpathname))
                            {
                                aSETnodes[q].ListIsSelected = aSETnodes[q].outputListIsSelected = true;
                                string asetnodepath = q.Substring(q.LastIndexOf(stringspace) + 1);
                                if (!sortedTargetList.Contains(asetnodepath))
                                {
                                    sortedTargetList.Add(asetnodepath);
                                }
                                if (UselessMatexModel.Contains(q))
                                {
                                    UselessMatexModel.Remove(q);
                                }
                                if (selectingtypes.Contains(asetnodepath))
                                {
                                    selectingtypes.Remove(asetnodepath);
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                if (directoryPath != string.Empty)
                {
                    foreach (string q in aSETnodes.Keys)
                    {
                        if (q.StartsWith(directoryPath))
                        {
                            aSETnodes[q].ListIsSelected = aSETnodes[q].outputListIsSelected = true;
                            string asetnodepath = q.Substring(q.LastIndexOf(stringspace) + 1);
                            if (!sortedTargetList.Contains(asetnodepath))
                            {
                                sortedTargetList.Add(asetnodepath);
                            }
                            if (UselessMatexModel.Contains(q))
                            {
                                UselessMatexModel.Remove(q);
                            }
                            if (selectingtypes.Contains(asetnodepath))
                            {
                                selectingtypes.Remove(asetnodepath);
                            }
                        }
                    }
                }
            }
        }

        /***********种类排序************/
        sortedTargetList = SortTypeNode(ASWFolderNames, sortedTargetList);//按照ASWFolderNames列表排序
        selectingtypes = SortTypeNode(ASWFolderNames, selectingtypes);//按照ASWFolderNames列表排序
        for (int k = 0; k < selectingtypes.Count; k++)
        {
            sortedTargetList.Add(selectingtypes[k]);
        }
        Dictionary<string, ASETnode> aSETnodestemp = new Dictionary<string, ASETnode>();
        List<string> aSETnodestemp2 = new List<string>(aSETnodes.Keys);
        intypecount = new int[sortedTargetList.Count];

        allnoneselectdependIS = new bool[2 * 4];        //0,2,4,6存所有，所选，依赖，无用文件的状态
        allnoneselectdependIS[2] = true;        //所选
        allnoneselectdependIS[4] = true;        //依赖
        allnoneselectdependIS[6] = false;        //无用

        bool ISDependCSexist = false;
        for (int i = 0; i < sortedTargetList.Count; i++)
        {
            string typei = sortedTargetList[i];
            List<string> aSETnodestemp3 = new List<string>();       //辅助加速让下面的for遍历数量减少，从而变快
            for (int p = 0; p < aSETnodestemp2.Count; p++)
            {
                string q = aSETnodestemp2[p];
                string stringspacetypei = stringspace + typei;      //避免判断Shaders和ComputeShaders相同
                if (IsSuff(q, stringspacetypei))
                {
                    ISDependCSexist |= typei == ASWFolderNames[5] && !aSETnodes[q].ListIsSelected;
                    ISDependFileExist |= !aSETnodes[q].ListIsSelected;
                    allnoneselectdependIS[4] &= aSETnodes[q].outputListIsSelected;
                    aSETnodestemp.Add(q, aSETnodes[q]);
                    intypecount[i]++;
                    aSETnodestemp3.Add(q);
                }
            }
            for (int p = 0; p < aSETnodestemp3.Count; p++)
            {
                string q = aSETnodestemp3[p];
                aSETnodestemp2.Remove(q);
            }
        }
        aSETnodes = aSETnodestemp;
        allnoneselectdependIS[0] = allnoneselectdependIS[4];


        selectedtypetemp.Add(ASWFolderNames[0]);

        SearchSelectOneSeqtranstemp = new float[ASETnodeallcount];
        SearchSelectOne = new bool[ASETnodeallcount];
        for (int i = 0; i < ASETnodeallcount; i++)
        {
            SearchSelectOneSeqtranstemp[i] = 1;
            SearchSelectOne[i] = false;
        }
        SearchSelectOne[0] = true;
    }
    private int SearchNum = 0;
    private string myString = "ExportPackage";
    private string Search = string.Empty;
    private string Searchtemp = "、";
    private string test = "1";
    private string test1 = "1";
    private string test2 = "1";
    private string test3 = "1";
    // float Remap(float x, float t1, float t2, float s1, float s2)
    // {
    //     return (x - t1) / (t2 - t1) * (s2 - s1) + s1;
    // }
    private List<string> ListHeadClickSeleted = new List<string>();     //高亮头文件
    private bool[] allnoneselectdependIS;       //左上角UI相关
    private bool ISDependFileExist = false;
    private float zoomstartvaluetime = 1f;
    private bool isexpend = false;
    private Rect expandbuttonrect = new Rect(0, 0, 1, 1);

    private void OnGUI()
    {
        if (EditorApplication.isPlayingOrWillChangePlaymode || EditorApplication.isCompiling)
        {
            wnd.Close();
            return;
        }
        if (ASETnodeallcount == 0)
        // if (assetPathNamesC == 0)
        {
            EditorUtility.DisplayDialog("Notification", "Please select files in Assets folder!", "OK");
            wnd.Close();
            return;
        }
        // Repaint();
        EditorGUILayout.Space(3f);
        Event ec = Event.current;

        /**********搜索UI相关************/
        GUILayout.BeginHorizontal();
        {
            float searchwidth = .0f;
            Rect SearchTemp = new Rect();
            if (SearchNum > 0)
            {
                searchwidth = 175f;
                SearchTemp = new Rect(15, 5, position.width - 187f, 17f);
            }
            else
            {
                if (Search.Length > 0)
                {
                    searchwidth = 90f;
                    SearchTemp = new Rect(15, 5, position.width - 102f, 17f);
                }
                else
                {
                    searchwidth = 6f;
                    SearchTemp = new Rect(15, 5, position.width - 19f, 17f);
                }
            }
            Search = GUILayout.TextField(Search, "SearchTextField", GUILayout.Width(position.width - searchwidth));

            GUIStyle TransparentTextField = new GUIStyle(EditorStyles.whiteLabel);
            TransparentTextField.normal.textColor = EditorStyles.textField.normal.textColor;
            EditorGUI.TextField(SearchTemp, string.Empty, TransparentTextField);

            GUIStyle PleaseInput = new GUIStyle(GUI.skin.label);
            PleaseInput.fontSize = 11;
            PleaseInput.normal.textColor = Color.white * 0.65f;
            if (Search.Length == 0) EditorGUI.LabelField(new Rect(16f, 2.5f, 50f, 20f), "Enter...", PleaseInput);
            if (!GUILayoutUtility.GetLastRect().Contains(ec.mousePosition) && ec.type == EventType.MouseDown)
            {
                GUIUtility.keyboardControl = 0;
                Repaint();
            }
            if (Search.Length > 0)
            {

                bool ISearchNum = SearchNum > 0;
                if (ISearchNum)
                {
                    GUILayout.Label((nowsearchindex + 1) + stringslash + SearchNum, "CenteredLabel", GUILayout.Height(15f));

                    if (GUILayout.Button("▲", GUILayout.Width(30f), GUILayout.Height(17f)))
                    {
                        nowsearchindex--;
                        if (nowsearchindex < 0)
                        {
                            nowsearchindex = SearchNum - 1;
                        }
                        nowsearchindex %= SearchNum;
                        // Searchstate();
                    }

                    if (GUILayout.Button("▼", GUILayout.Width(30f), GUILayout.Height(17f)))
                    {
                        nowsearchindex++;
                        nowsearchindex %= SearchNum;
                    }
                }
                else
                {
                    GUILayout.Label("0/0", "CenteredLabel", GUILayout.Height(15f));
                    GUI.changed = true;

                }
                if (GUILayout.Button("✖", GUILayout.Width(30f), GUILayout.Height(17f)))
                {
                    Search = string.Empty;
                    GUI.changed = true;
                }
            }
            SearchNum = 0;
        }
        GUILayout.EndHorizontal();
        /**********搜索UI相关************/

        EditorGUILayout.Space(0.2f);

        // GUILayout.BeginVertical("HelpBox");
        GUILayout.BeginVertical();
        {

            EditorGUILayout.Space(position.height - 62);
            // EditorGUILayout.Space(position.height - 95);


            /**********底部输入导出文件夹+导出按钮UI************/
            GUIStyle textStyleText = new GUIStyle("ScriptText");
            string AssetsAndSlash = ASWFolderNames[21] + stringslash;
            textStyleText.contentOffset = new Vector2(42.4f, 0f);
            textStyleText.fontSize = 12;
            textStyleText.normal.textColor = Color.clear;

            if (myString.StartsWith(AssetsAndSlash))
            {
                myString = myString.Substring(7);
                GUIUtility.keyboardControl = 0;
            }
            float labelsheight = position.height - 55 + 26;
            GUI.Label(new Rect(10, labelsheight, position.width - 20, 20), "Export Path:");
            float closexportpathdis = -65f;
            myString = EditorGUI.TextField(new Rect(10 + closexportpathdis + 152.5f, labelsheight, position.width - 200, 20), string.Empty, myString, textStyleText);
            if (!GUILayoutUtility.GetLastRect().Contains(ec.mousePosition) && ec.type == EventType.MouseDown)
            {
                GUIUtility.keyboardControl = 0;
                Repaint();
            }
            EditorGUI.LabelField(new Rect(165 + closexportpathdis, labelsheight, position.width - 200, 20), AssetsAndSlash + myString);
            GUIStyle exportextguistyle = new GUIStyle("wordwrapminibutton");
            exportextguistyle.fontSize = 14;
            exportextguistyle.contentOffset = new Vector2(0, -0.45f);
            bool exportrue = false;
            if (GUI.Button(new Rect(position.width - 200 + 100 + 10, labelsheight, 80, 22), "EXPORT!", exportextguistyle))
            {
                string finalstring = AssetsAndSlash + myString;
                List<string> finalstringsplit = new List<string>(finalstring.Split(new char[] { '/', '\\' }));
                if (finalstringsplit.Contains(string.Empty))
                {
                    ShowNotification(new GUIContent("Please enter the correct export folder name!"), 2.0f);
                }
                else
                {
                    exportrue = true;
                }
            }
            /**********底部输入导出文件夹+导出按钮UI************/

            int allselectedcount = 0;
            int allselectednowcount = 0;
            int alldependcount = 0;
            int alldependnowcount = 0;
            int allhidcount = UselessMatexModel.Count;
            int allhidnowcount = 0;

            /**********Core************/

            int selectedCount = 0;
            HandleEvents();     //这个只能放在外面，要不然会影响位置偏移
            _zoomArea = new Rect(4f, 25.5f, position.width - 8f, position.height - 62);
            GUI.Box(_zoomArea, string.Empty, "CurveEditorBackground");
            bool iscancelcurrent = true;
            ZoomBegin(_zoom, _zoomArea);
            {
                // if (_zoom > kZoomMin)
                // {
                DrawGrid(new Vector2(Screen.width, Screen.height), 20, 1 / _zoom, EditorGUIUtility.isProSkin ? new Color(0.5f, 0.5f, 0.5f, 0.1f) : Color.white * 0.2f);      //背景网格
                // }
                List<Vector2> typenamelist = new List<Vector2>();
                Rect zoomexpandbuttonrect = new Rect(expandbuttonrect.x / _zoom - 5, expandbuttonrect.y / _zoom - 50, expandbuttonrect.width / _zoom, expandbuttonrect.height / _zoom);   //使其不与右键双击后的GUI冲突
                // GUI.Box(zoomexpandbuttonrect, "asdasda", "Wizard Box");
                if (Isreversedependent)
                {
                    ShownodeR();
                }
                else
                {
                    Shownode(ref allselectedcount, ref allselectednowcount, ref alldependcount, ref alldependnowcount, ref allhidnowcount, ref iscancelcurrent, ref typenamelist, zoomexpandbuttonrect);
                    ShownodeLine(ref selectedCount, exportrue, typenamelist);
                }

                // float bias = 20;
                // Rect biaspos = new Rect(float.Parse(test), float.Parse(test1), float.Parse(test2), float.Parse(test3));
                // if (_zoomCoordsOrigin.x < biaspos.width - bias / _zoom + biaspos.x && _zoomCoordsOrigin.y < biaspos.height - bias / _zoom + biaspos.y)
                // {
                //     if (biaspos.x - _zoomCoordsOrigin.x < (position.width - 8 - bias) / _zoom && biaspos.y - _zoomCoordsOrigin.y < (position.height - 62f - bias) / _zoom)
                //     {
                //         GUI.Box(new Rect(biaspos.x - _zoomCoordsOrigin.x, biaspos.y - _zoomCoordsOrigin.y, biaspos.width, biaspos.height), "test");
                //     }
                // }
                // DrawLineFrame(new Rect(bias / _zoom, bias / _zoom, (position.width - 8 - bias * 2) / _zoom, (position.height - 62f - bias * 2) / _zoom), Color.red, 2);
            }
            ZoomEnd();


            if (Isreversedependent)
            {
                GUIStyle reversereturnbutton = new GUIStyle("button");
                reversereturnbutton.fontSize = 20;
                reversereturnbutton.normal.textColor = EditorGUIUtility.isProSkin ? new Color(0.9f, 0.9f, 0.9f, 1.0f) : new Color(0.1f, 0.1f, 0.1f, 1.0f);
                if (GUI.Button(new Rect(10, 32, 40, 30), "◀", reversereturnbutton))
                {
                    Isreversedependent = false;
                }
            }




            /**********Core************/

            if (expandbuttonrect.Contains(ec.mousePosition))
            {
                iscancelcurrent = false;
            }
            if (iscancelcurrent && ec.type == EventType.MouseDown && ec.button == 0)
            {
                currentSelectedIndex.Clear();
                ListHeadClickSeleted.Clear();
                foreach (string i in aSETnodes.Keys)
                {
                    aSETnodes[i].ListMouseClickIsSelected = false;
                }
                GUI.changed = true;
            }

            // /**********全选，所选蓝色全选，依赖红色全选************/

            // GUIStyle InterfaceGUI = new GUIStyle();
            // InterfaceGUI.fontSize = 15;
            // InterfaceGUI.normal.textColor = EditorGUIUtility.isProSkin ? Color.white : new Color(0.2f, 0.2f, 0.2f, 1f);
            // InterfaceGUI.contentOffset = new Vector2(0, 6);
            // string fontcountcontent = "Files Count: (" + selectedCount + stringslash + ASETnodeallcount + ")";

            // float fontlengthwidth = fontcountcontent.Length * (0.5f * InterfaceGUI.fontSize + 1.0667f);


            float fontlengthwidth = 180f;
            // float sidewidth = 10;
            // float sideheight = 52f;
            int isdtimer = 0;
            bool uselessgreater0 = allhidcount > 0;
            if (ISDependFileExist)
            {
                if (uselessgreater0)
                {
                    isdtimer = 4;
                }
                else
                {
                    isdtimer = 3;
                }
            }
            else
            {
                if (uselessgreater0)
                {
                    isdtimer = 3;
                }
                else
                {
                    isdtimer = 2;
                }
            }
            float uihe = 25 * isdtimer + 5;
            // Rect expandbuttonrect = new Rect(4, sideheight, isexpend ? fontlengthwidth : 15, uihe);
            if (ec.type == EventType.MouseDown && ec.button == 1 && ec.clickCount == 2 && _zoomArea.Contains(ec.mousePosition))
            {
                expandbuttonrect = new Rect(ec.mousePosition.x, ec.mousePosition.y, fontlengthwidth, uihe);
                isexpend = true;
            }
            if (isexpend)
            {
                if (expandbuttonrect.Contains(ec.mousePosition))
                {

                    // isexpend = true;
                    // GUI.Box(new Rect(sidewidth, sideheight, fontlengthwidth, 30), string.Empty, "HelpBox");
                    // if (EditorGUIUtility.isProSkin)
                    // {
                    //     GUIStyle boxguis = new GUIStyle();
                    //     boxguis.normal.background = MakeTex(1, 1, new Color(0.35f, 0.35f, 0.35f, 1.0f));
                    //     GUI.Box(new Rect(sidewidth + 3f, sideheight + 3f, fontlengthwidth - 6, 30 - 6), string.Empty, boxguis);
                    // }
                    // else
                    // {
                    //     GUI.Box(new Rect(sidewidth + 3f, sideheight + 3f, fontlengthwidth - 6, 30 - 6), string.Empty, "GroupBox");
                    // }

                    // GUI.Label(new Rect(sidewidth + 8f, sideheight, 100, 20), fontcountcontent, InterfaceGUI);

                    GUILayout.BeginArea(expandbuttonrect, string.Empty);
                    {
                        // GUILayout.BeginHorizontal();
                        // {
                        GUIStyle boxguisty = new GUIStyle();
                        boxguisty.normal.background = MakeTex(1, 1, EditorGUIUtility.isProSkin ? new Color(0.8f, 0.8f, 0.8f, 0.8f) : new Color(0.2f, 0.2f, 0.2f, 0.8f));
                        GUILayout.BeginVertical(boxguisty);
                        {
                            // GUI.color = new Color(0.75f, 0.0f, 0.75f, 1.0f);
                            // if (GUILayout.Button((allnoneselectdependIS[0] ? "None" : "All") + " (" + selectedCount + stringslash + ASETnodeallcount + ")", GUILayout.Height(23)))
                            if (GUILayout.Button(string.Empty, GUILayout.Height(23)))
                            {
                                allnoneselectdependIS[0] = !allnoneselectdependIS[0];
                                allnoneselectdependIS[1] = true;
                            }
                            // GUI.color = Color.white;
                            // GUI.color = new Color(0.32f, 0.32f, 0.85f, 1.0f);
                            GUI.color = new Color(0.0f, 0.0f, 1f, 1.0f);
                            // if (GUILayout.Button("Selected Files " + allselectednowcount + stringslash + allselectedcount, GUILayout.Height(23)))
                            if (GUILayout.Button(string.Empty, GUILayout.Height(23)))
                            {
                                allnoneselectdependIS[2] = !allnoneselectdependIS[2];
                                allnoneselectdependIS[3] = true;
                            }
                            GUI.color = Color.white;
                            // GUIStyle buttonfontcolor = new GUIStyle();
                            // buttonfontcolor.normal.textColor = new Color(0.95f, 0.95f, 0.95f, 1.0f);
                            // GUI.Label(new Rect(36, 32, 100, 100), "Selected Files " + allselectednowcount + stringslash + allselectedcount, buttonfontcolor);
                            if (ISDependFileExist)
                            {
                                // GUI.color = new Color(0.85f, 0.32f, 0.32f, 1.0f);
                                GUI.color = new Color(1f, 0.0f, 0.0f, 1.0f);

                                // if (GUILayout.Button("Dependent Files " + alldependnowcount + stringslash + alldependcount, GUILayout.Height(23)))
                                if (GUILayout.Button(string.Empty, GUILayout.Height(23)))
                                {
                                    allnoneselectdependIS[4] = !allnoneselectdependIS[4];
                                    allnoneselectdependIS[5] = true;
                                }
                                GUI.color = Color.white;
                                // GUI.Label(new Rect(15, 57, 100, 100), "Dependent Files " + alldependnowcount + stringslash + alldependcount, buttonfontcolor);
                            }
                            if (uselessgreater0)
                            {
                                // GUI.color = new Color(0.85f, 0.32f, 0.32f, 1.0f);
                                GUI.color = new Color(1f, 0.0f, 1.0f, 1.0f);

                                // if (GUILayout.Button("Hidden Files " + allhidnowcount + stringslash + allhidcount, GUILayout.Height(23)))
                                if (GUILayout.Button(string.Empty, GUILayout.Height(23)))
                                {
                                    allnoneselectdependIS[6] = !allnoneselectdependIS[6];
                                    allnoneselectdependIS[7] = true;
                                }
                                GUI.color = Color.white;
                                // GUI.Label(new Rect(40.5f, 82, 100, 100), "Hidden Files " + allhidnowcount + stringslash + allhidcount, buttonfontcolor);
                            }
                        }
                        GUILayout.EndVertical();
                    }
                    GUILayout.EndArea();

                    GUILayout.BeginArea(expandbuttonrect, string.Empty);
                    {
                        GUILayout.Space(4f);
                        GUIStyle buttonfontcolor = new GUIStyle();
                        buttonfontcolor.alignment = TextAnchor.MiddleCenter;
                        buttonfontcolor.fontSize = 13;
                        buttonfontcolor.normal.textColor = EditorGUIUtility.isProSkin ? new Color(0.95f, 0.95f, 0.95f, 1.0f) : new Color(0.1f, 0.1f, 0.1f, 1.0f);
                        GUILayout.Label((allnoneselectdependIS[0] ? "None" : "All") + " (" + selectedCount + stringslash + ASETnodeallcount + ")", buttonfontcolor, GUILayout.Height(22));
                        buttonfontcolor.normal.textColor = new Color(0.95f, 0.95f, 0.95f, 1.0f);
                        buttonfontcolor.fontSize = 0;
                        GUILayout.Label("Selected Files (" + allselectednowcount + stringslash + allselectedcount + ")", buttonfontcolor, GUILayout.Height(25));
                        if (ISDependFileExist)
                        {
                            // if (!EditorGUIUtility.isProSkin)
                            // {
                            //     buttonfontcolor.normal.textColor = new Color(0.1f, 0.1f, 0.1f, 1.0f);
                            // }
                            GUILayout.Label("Dependent Files (" + alldependnowcount + stringslash + alldependcount + ")", buttonfontcolor, GUILayout.Height(24.5f));
                        }
                        if (uselessgreater0)
                        {
                            if (!EditorGUIUtility.isProSkin)
                            {
                                buttonfontcolor.normal.textColor = new Color(0.1f, 0.1f, 0.1f, 1.0f);
                            }
                            GUILayout.Label("Hidden Files (" + allhidnowcount + stringslash + allhidcount + ")", buttonfontcolor, GUILayout.Height(27f));
                        }
                    }
                    GUILayout.EndArea();

                    // string stringcleanhl = "Clean All Highlight Node";
                    // Rect cleanallhighlightrect = new Rect(sidewidth, sideheight + 35 + 25 * isdtimer + 10, stringcleanhl.Length * 7f, 30);
                    // GUI.Box(cleanallhighlightrect, string.Empty, "HelpBox");
                    // float chtimer = 2.5f;
                    // if (GUI.Button(new Rect(cleanallhighlightrect.x + chtimer, cleanallhighlightrect.y + chtimer, cleanallhighlightrect.width - chtimer * 2, cleanallhighlightrect.height - chtimer * 2), stringcleanhl))
                    // {
                    //     // foreach (string i in aSETnodes.Keys)
                    //     // {
                    //     //     aSETnodes[i].ListMouseClickIsSelected = false;
                    //     // }
                    //     // ListHeadClickSeleted.Clear();
                    //     currentSelectedIndex.Clear();
                    // }
                }
                else
                {
                    isexpend = false;
                    expandbuttonrect = new Rect(0, 0, 1, 1);
                }
            }
            // else
            // {
            //     GUI.Label(expandbuttonrect, string.Empty, "PreVerticalScrollbarThumb");
            //     // isexpend = false;
            // }


            /**********全选，所选蓝色全选，依赖红色全选************/


            test = GUI.TextArea(new Rect(position.width - 100, position.height - 400, 40, 20), test); //UnityEngine.Debug.Log(test);
            test1 = GUI.TextArea(new Rect(position.width - 100, position.height - 300, 40, 20), test1); //UnityEngine.Debug.Log( test);
            test2 = GUI.TextArea(new Rect(position.width - 100, position.height - 200, 40, 20), test2); //UnityEngine.Debug.Log(test);
            test3 = GUI.TextArea(new Rect(position.width - 100, position.height - 100, 40, 20), test3); //UnityEngine.Debug.Log(test);

        }
        GUILayout.EndVertical();


        if (Searchtemp != Search)
        {
            Searchtemp = Search;
            nowsearchindextemp = -1;
            nowsearchindex = 0;
        }

    }
    private void Createdirectory1(string path)      //创建文件夹
    {
        Directory.CreateDirectory(path);
        // AssetDatabase.Refresh();
    }
    private void Movecore(string sourcepath, string destinationpath)        //移动文件相关
    {
        if (sourcepath != destinationpath)
        {
            File.Move(sourcepath, destinationpath);
            File.Move(sourcepath + Stringmeta, destinationpath + Stringmeta);
            // AssetDatabase.Refresh();
        }
    }
    private void Deletecore(string sourcepath)      //删除相关
    {
        if (File.Exists(sourcepath))
        {
            File.Delete(sourcepath);
            File.Delete(sourcepath + Stringmeta);
        }
        else if (Directory.Exists(sourcepath))
        {
            Directory.Delete(sourcepath, true);
            File.Delete(sourcepath + Stringmeta);
        }
        // AssetDatabase.Refresh();
    }
    private string Detectsamepathname(ref Dictionary<string, int> outputPathsamepath, string newpath2lower, string fileName, string destinatefile, string nowpathname1, ref Dictionary<string, bool> isfinalstringexist)        //检测是否用同样的文件
    {
        string newfolderpath = string.Empty;
        bool direcexistnewfolder = false;
        do
        {
            outputPathsamepath[newpath2lower]++;
            string newfoldersname = fileName.Substring(0, fileName.LastIndexOf(".")) + " (" + outputPathsamepath[newpath2lower] + ")";
            newfolderpath = destinatefile + stringslash + newfoldersname;
            direcexistnewfolder = !Directory.Exists(newfolderpath);

        } while (!direcexistnewfolder && Directory.GetFiles(newfolderpath).Length > 0 && !nowpathname1.StartsWith(newfolderpath));
        isfinalstringexist.Add(newfolderpath, direcexistnewfolder);
        if (direcexistnewfolder)
        {
            Createdirectory1(newfolderpath);
        }
        string newpath2 = newfolderpath + stringslash + fileName;
        return newpath2;
    }
    private void Classify(string nowpathname1, string finalstring, string nowtypename1, ref List<string> outputnewPathList, ref List<string> outputoldPathList, ref Dictionary<string, int> outputPathsamepath, ref Dictionary<string, bool> isfinalstringexist)
    {
        string destinatefile = finalstring + stringslash + nowtypename1;
        if (!isfinalstringexist.ContainsKey(destinatefile))
        {
            isfinalstringexist.Add(destinatefile, !Directory.Exists(destinatefile));
        }

        if (!Directory.Exists(destinatefile))
        {
            Createdirectory1(destinatefile);
        }
        string fileName = System.IO.Path.GetFileName(nowpathname1);
        string filename2lower = fileName.ToLower();

        string newpath2lower = destinatefile + stringslash + filename2lower;
        if (!outputPathsamepath.ContainsKey(newpath2lower))
        {
            string newpath1 = destinatefile + stringslash + fileName;
            outputPathsamepath.Add(newpath2lower, 0);
            if (File.Exists(newpath1) && nowpathname1 != newpath1)
            {
                newpath1 = Detectsamepathname(ref outputPathsamepath, newpath2lower, fileName, destinatefile, nowpathname1, ref isfinalstringexist);
            }
            outputnewPathList.Add(newpath1);
            outputoldPathList.Add(nowpathname1);
            Movecore(nowpathname1, newpath1);
        }
        else
        {
            string newpath1 = Detectsamepathname(ref outputPathsamepath, newpath2lower, fileName, destinatefile, nowpathname1, ref isfinalstringexist);
            outputnewPathList.Add(newpath1);
            outputoldPathList.Add(nowpathname1);
            Movecore(nowpathname1, newpath1);
        }
    }
    private void MoveArray(List<string> outputnewPathList, List<string> outputoldPathList, string finalstring, ref Dictionary<string, bool> isfinalstringexist)
    {
        for (int i = 0; i < outputnewPathList.Count; i++)
        {
            string newpath = outputnewPathList[i];
            string oldpath = outputoldPathList[i];
            Movecore(newpath, oldpath);
        }
        if (isfinalstringexist[finalstring])
        {
            Deletecore(finalstring);
        }
        else
        {
            foreach (string i in isfinalstringexist.Keys)
            {
                if (isfinalstringexist[i])
                {
                    Deletecore(i);
                }
            }
        }
    }
    private void ReturnAndDeleteFile(List<string> outputnewPathList, List<string> outputoldPathList, string finalstring, bool isRMSexist, ref Dictionary<string, bool> isfinalstringexist)
    {
        if (shaderincludes.Count > 0)
        {
            foreach (ShaderIncludeON sv in shaderincludes.Values)
            {
                File.WriteAllText(sv.newpath, sv.oldname);
            }
            AssetDatabase.Refresh();
        }
        if (isRMSexist)
        {
            int i = 0;
            for (; i < outputnewPathList.Count - 1; i++)
            {
                string newpath = outputnewPathList[i];
                string oldpath = outputoldPathList[i];
                Movecore(newpath, oldpath);
            }
            if (isfinalstringexist[finalstring])
            {
                Deletecore(finalstring);
            }
            else
            {
                string newpathNoldlastpath = outputnewPathList[i];
                Deletecore(newpathNoldlastpath);
            }
        }
        else
        {
            MoveArray(outputnewPathList, outputoldPathList, finalstring, ref isfinalstringexist);
        }
    }
    private void GenerateRMS(string _geID__J_fR, out string _KhPQyM___U)
    {
        _KhPQyM___U = _geID__J_fR + "/RemoveMissingScripts.cs";
        File.WriteAllText(_KhPQyM___U, "using System.IO;using UnityEditor;using UnityEditor.SceneManagement;using UnityEngine;using UnityEngine.SceneManagement;[InitializeOnLoad]public class RemoveMissingScripts{static string directoryPath =\"" + _geID__J_fR + "\";static bool IsSuff(string path, string pattern){int pL = path.Length - 1;int paL = pattern.Length - 1;bool Isuff = true;for(int i = pL; paL >= 0; i--){Isuff &= path[i] == pattern[paL--];}return Isuff;}static RemoveMissingScripts(){EditorApplication.delayCall += LASSapply;EditorApplication.delayCall += DeleteSelf;}static void LASSapply(){string[] guids = AssetDatabase.FindAssets(string.Empty, new[] { directoryPath });for (int i = 0; i < guids.Length; i++){string path = AssetDatabase.GUIDToAssetPath(guids[i]);if(!Directory.Exists(path)){if(IsSuff(path, \".unity\")){EditorSceneManager.OpenScene(path, OpenSceneMode.Additive);Scene scene = SceneManager.GetSceneAt(SceneManager.sceneCount > 1 ? 1 : 0);GameObject[] objectsInScene = scene.GetRootGameObjects();for (int k = 0; k < objectsInScene.Length; k++){GameObject oisk = objectsInScene[k];Search(oisk);}EditorSceneManager.SaveScene(scene);EditorSceneManager.CloseScene(scene, true);}else if(IsSuff(path, \".prefab\")){GameObject prefab = AssetDatabase.LoadAssetAtPath<GameObject>(path);Search(prefab);}}}AssetDatabase.Refresh();}static void Search(GameObject go){foreach (Transform child in go.transform)Search(child.gameObject);GameObjectUtility.RemoveMonoBehavioursWithMissingScript(go);}static void DeleteSelf(){File.Delete(directoryPath + \"/RemoveMissingScripts.cs\");File.Delete(directoryPath + \"/RemoveMissingScripts.cs.meta\");AssetDatabase.Refresh();}}");
        AssetDatabase.Refresh();
    }
    private void ExportCore(string i, string finalstring, string nowtypename1, string nowpathname1, ref List<string> outputnewPathList, ref List<string> outputoldPathList, ref Dictionary<string, int> outputPathsamepath, ref Dictionary<string, bool> isfinalstringexist)
    {
        List<string> finalstringsplit = new List<string>(finalstring.Split(new char[] { '/', '\\' }));
        if (finalstringsplit.Contains(string.Empty))
        {
            ShowNotification(new GUIContent("Please enter the correct export folder name!"), 2.0f);
        }
        else
        {
            if (aSETnodes[i].outputListIsSelected)
            {
                if (nowtypename1 == ASWFolderNames[3])
                {
                    bool scke = shaderincludes.ContainsKey(nowpathname1);
                    if (scke)
                    {
                        string shadernewtext = shaderincludes[nowpathname1].newname;
                        File.WriteAllText(nowpathname1, shadernewtext);
                        AssetDatabase.Refresh();
                    }
                    Classify(nowpathname1, finalstring, nowtypename1, ref outputnewPathList, ref outputoldPathList, ref outputPathsamepath, ref isfinalstringexist);
                    if (scke)
                    {
                        string outputPathListlast = outputnewPathList[outputnewPathList.Count - 1];
                        shaderincludes[nowpathname1].newpath = outputPathListlast;
                    }
                }
                else
                {
                    Classify(nowpathname1, finalstring, nowtypename1, ref outputnewPathList, ref outputoldPathList, ref outputPathsamepath, ref isfinalstringexist);
                }
            }
        }
    }
    private void DrawNodeCurve(Rect start, Rect end, float linewidth, Color curvecolor, string nowpathname1, float clampzoom2)     //连线相关
    {
        bool headnowis = ListHeadClickSeleted.Contains(nowpathname1);

        Vector3 startPos = new Vector3(start.x + start.width / 2, start.y + start.height, 0);
        Vector3 endPos = new Vector3(end.x + end.width / 2, end.y - 20 / clampzoom2, 0);

        float notequalbias = 1f; //精度问题
        bool issamecolumn = startPos.y > endPos.y - notequalbias && startPos.y < endPos.y + notequalbias;
        bool isleftcolumn = startPos.y < endPos.y - notequalbias;
        bool isrightcolumn = startPos.y > endPos.y + notequalbias;
        bool issamerow = startPos.x > endPos.x - notequalbias && startPos.x < endPos.x + notequalbias;
        bool isleftrow = startPos.x < endPos.x - notequalbias;
        bool isrightrow = startPos.x > endPos.x + notequalbias;

        float cornercurvelengthx = 20;
        float cornercurvelengthystart = columnysametype * (58f * clampzoom2 - 18f);
        // UnityEngine.Debug.Log(clampzoom2);
        // UnityEngine.Debug.Log(1 / clampzoom2);
        float cornercurvelengthyend = columnysametype * (56f * clampzoom2 - 31f);
        float straightlinelength = rowx * 0.5f - 40f;

        float startendminx = Mathf.Min(startPos.x, endPos.x);
        float startendminy = Mathf.Min(startPos.y, endPos.y);
        float startendmaxx = Mathf.Max(startPos.x, endPos.x);
        float startendmaxy = Mathf.Max(startPos.y, endPos.y);
        Rect lineRectemp = new Rect(startendminx, startendminy, Mathf.Abs(startendmaxx - startendminx), Mathf.Abs(startendmaxy - startendminy));
        if (-lineRectemp.x < lineRectemp.width && -lineRectemp.y < lineRectemp.height)
        {
            if (lineRectemp.x < (position.width - 8) / _zoom && lineRectemp.y < (position.height - 62f) / _zoom)
            {
                // GUI.Box(lineRectemp, string.Empty);
                if (isrightcolumn)
                {
                    if (isrightrow)
                    {
                        Vector3 linenode1 = new Vector3(startPos.x - cornercurvelengthx, startPos.y + cornercurvelengthystart, 0);
                        Vector3 linenode2 = new Vector3(startPos.x - cornercurvelengthx - straightlinelength, startPos.y + cornercurvelengthystart, 0);
                        Vector3 linenode3 = new Vector3(startPos.x - cornercurvelengthx * 2 - straightlinelength, startPos.y, 0);
                        Vector3 linenode4 = new Vector3(startPos.x - cornercurvelengthx * 2 - straightlinelength, endPos.y, 0);
                        Vector3 linenode5 = new Vector3(startPos.x - cornercurvelengthx * 3 - straightlinelength, endPos.y - cornercurvelengthyend, 0);
                        Vector3 linenode6 = new Vector3(endPos.x + cornercurvelengthx, endPos.y - cornercurvelengthyend, 0);
                        Handles.DrawBezier(startPos, linenode1, new Vector3(startPos.x, linenode1.y, 0), new Vector3(startPos.x, linenode1.y, 0), curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode1, linenode2, linenode1 + Vector3.left, linenode2 + Vector3.right, curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode2, linenode3, new Vector3(linenode3.x, linenode2.y, 0), new Vector3(linenode3.x, linenode2.y, 0), curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode3, linenode4, linenode3 + Vector3.up, linenode4 + Vector3.down, curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode4, linenode5, new Vector3(linenode4.x, linenode5.y, 0), new Vector3(linenode4.x, linenode5.y, 0), curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode5, linenode6, linenode5 + Vector3.left, linenode6 + Vector3.right, curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode6, endPos, new Vector3(endPos.x, linenode6.y, 0), new Vector3(endPos.x, linenode6.y, 0), curvecolor, null, linewidth);

                    }
                    else if (issamerow)
                    {
                        Vector3 linenode1 = new Vector3(startPos.x + cornercurvelengthx, startPos.y + cornercurvelengthystart, 0);
                        Vector3 linenode2 = new Vector3(startPos.x + cornercurvelengthx + straightlinelength, startPos.y + cornercurvelengthystart, 0);
                        Vector3 linenode3 = new Vector3(startPos.x + cornercurvelengthx * 2 + straightlinelength, startPos.y, 0);
                        Vector3 linenode4 = new Vector3(endPos.x + cornercurvelengthx * 2 + straightlinelength, endPos.y, 0);
                        Vector3 linenode5 = new Vector3(endPos.x + cornercurvelengthx + straightlinelength, endPos.y - cornercurvelengthyend, 0);
                        Vector3 linenode6 = new Vector3(endPos.x + cornercurvelengthx, endPos.y - cornercurvelengthyend, 0);
                        Handles.DrawBezier(startPos, linenode1, new Vector3(startPos.x, linenode1.y, 0), new Vector3(startPos.x, linenode1.y, 0), curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode1, linenode2, linenode1 + Vector3.right, linenode2 + Vector3.left, curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode2, linenode3, new Vector3(linenode3.x, linenode2.y, 0), new Vector3(linenode3.x, linenode2.y, 0), curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode3, linenode4, linenode3 + Vector3.up, linenode4 + Vector3.down, curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode4, linenode5, new Vector3(linenode4.x, linenode5.y, 0), new Vector3(linenode4.x, linenode5.y, 0), curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode5, linenode6, linenode5 + Vector3.left, linenode6 + Vector3.right, curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode6, endPos, new Vector3(endPos.x, linenode6.y, 0), new Vector3(endPos.x, linenode6.y, 0), curvecolor, null, linewidth);

                    }
                    else
                    {
                        Vector3 linenode1 = new Vector3(startPos.x + cornercurvelengthx, startPos.y + cornercurvelengthystart, 0);
                        Vector3 linenode2 = new Vector3(startPos.x + cornercurvelengthx + straightlinelength, startPos.y + cornercurvelengthystart, 0);
                        Vector3 linenode3 = new Vector3(startPos.x + cornercurvelengthx * 2 + straightlinelength, startPos.y, 0);
                        Vector3 linenode4 = new Vector3(startPos.x + cornercurvelengthx * 2 + straightlinelength, endPos.y, 0);
                        Vector3 linenode5 = new Vector3(startPos.x + cornercurvelengthx * 3 + straightlinelength, endPos.y - cornercurvelengthyend, 0);
                        Vector3 linenode6 = new Vector3(endPos.x - cornercurvelengthx, endPos.y - cornercurvelengthyend, 0);
                        Handles.DrawBezier(startPos, linenode1, new Vector3(startPos.x, linenode1.y, 0), new Vector3(startPos.x, linenode1.y, 0), curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode1, linenode2, linenode1 + Vector3.right, linenode2 + Vector3.left, curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode2, linenode3, new Vector3(linenode3.x, linenode2.y, 0), new Vector3(linenode3.x, linenode2.y, 0), curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode3, linenode4, linenode3 + Vector3.up, linenode4 + Vector3.down, curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode4, linenode5, new Vector3(linenode4.x, linenode5.y, 0), new Vector3(linenode4.x, linenode5.y, 0), curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode5, linenode6, linenode5 + Vector3.right, linenode6 + Vector3.left, curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode6, endPos, new Vector3(endPos.x, linenode6.y, 0), new Vector3(endPos.x, linenode6.y, 0), curvecolor, null, linewidth);
                    }
                }
                else if (isleftcolumn)
                {
                    if (isrightrow)
                    {
                        if (startPos.y + cornercurvelengthystart * 2 > endPos.y - cornercurvelengthyend * 2)
                        {
                            float halfstartend = headnowis ? 132f * clampzoom2 - 87f : 113.2f * clampzoom2 - 40.9f;
                            // float halfstartend = aSETnodesiListMouseClickIsSelected ? (newdepathNtypenodeListMouseClickIsSelected ? float.Parse(test2) : float.Parse(test1)) : float.Parse(test);
                            Vector3 linenode1 = new Vector3(startPos.x - cornercurvelengthx, startPos.y + halfstartend, 0);
                            Vector3 linenode2 = new Vector3(endPos.x + cornercurvelengthx, startPos.y + halfstartend, 0);
                            Handles.DrawBezier(startPos, linenode1, new Vector3(startPos.x, linenode1.y, 0), new Vector3(startPos.x, linenode1.y, 0), curvecolor, null, linewidth);
                            Handles.DrawBezier(linenode1, linenode2, linenode1 + Vector3.left, linenode2 + Vector3.right, curvecolor, null, linewidth);
                            Handles.DrawBezier(linenode2, endPos, new Vector3(endPos.x, linenode2.y, 0), new Vector3(endPos.x, linenode2.y, 0), curvecolor, null, linewidth);

                        }
                        else
                        {
                            Vector3 linenode1 = new Vector3(startPos.x - cornercurvelengthx, startPos.y + cornercurvelengthystart, 0);
                            Vector3 linenode2 = new Vector3(startPos.x - cornercurvelengthx - straightlinelength, startPos.y + cornercurvelengthystart, 0);
                            Vector3 linenode3 = new Vector3(startPos.x - cornercurvelengthx * 2 - straightlinelength, startPos.y + cornercurvelengthystart * 2, 0);
                            Vector3 linenode4 = new Vector3(startPos.x - cornercurvelengthx * 2 - straightlinelength, endPos.y - cornercurvelengthyend * 2, 0);
                            Vector3 linenode5 = new Vector3(startPos.x - cornercurvelengthx * 3 - straightlinelength, endPos.y - cornercurvelengthyend, 0);
                            Vector3 linenode6 = new Vector3(endPos.x + cornercurvelengthx, endPos.y - cornercurvelengthyend, 0);
                            Handles.DrawBezier(startPos, linenode1, new Vector3(startPos.x, linenode1.y, 0), new Vector3(startPos.x, linenode1.y, 0), curvecolor, null, linewidth);
                            Handles.DrawBezier(linenode1, linenode2, linenode1 + Vector3.left, linenode2 + Vector3.right, curvecolor, null, linewidth);
                            Handles.DrawBezier(linenode2, linenode3, new Vector3(linenode3.x, linenode2.y, 0), new Vector3(linenode3.x, linenode2.y, 0), curvecolor, null, linewidth);
                            Handles.DrawBezier(linenode3, linenode4, linenode3 + Vector3.down, linenode4 + Vector3.up, curvecolor, null, linewidth);
                            Handles.DrawBezier(linenode4, linenode5, new Vector3(linenode4.x, linenode5.y, 0), new Vector3(linenode4.x, linenode5.y, 0), curvecolor, null, linewidth);
                            Handles.DrawBezier(linenode5, linenode6, linenode5 + Vector3.left, linenode6 + Vector3.right, curvecolor, null, linewidth);
                            Handles.DrawBezier(linenode6, endPos, new Vector3(endPos.x, linenode6.y, 0), new Vector3(endPos.x, linenode6.y, 0), curvecolor, null, linewidth);

                        }
                    }
                    else if (issamerow)
                    {
                        Vector3 linenode1 = new Vector3(startPos.x + cornercurvelengthx, startPos.y + cornercurvelengthystart, 0);
                        Vector3 linenode2 = new Vector3(startPos.x + cornercurvelengthx + straightlinelength, startPos.y + cornercurvelengthystart, 0);
                        Vector3 linenode3 = new Vector3(startPos.x + cornercurvelengthx * 2 + straightlinelength, startPos.y + cornercurvelengthystart * 2, 0);
                        Vector3 linenode4 = new Vector3(endPos.x + cornercurvelengthx * 2 + straightlinelength, endPos.y - cornercurvelengthyend * 2, 0);
                        Vector3 linenode5 = new Vector3(endPos.x + cornercurvelengthx + straightlinelength, endPos.y - cornercurvelengthyend, 0);
                        Vector3 linenode6 = new Vector3(endPos.x + cornercurvelengthx, endPos.y - cornercurvelengthyend, 0);
                        Handles.DrawBezier(startPos, linenode1, new Vector3(startPos.x, linenode1.y, 0), new Vector3(startPos.x, linenode1.y, 0), curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode1, linenode2, linenode1 + Vector3.right, linenode2 + Vector3.left, curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode2, linenode3, new Vector3(linenode3.x, linenode2.y, 0), new Vector3(linenode3.x, linenode2.y, 0), curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode3, linenode4, linenode3 + Vector3.down, linenode4 + Vector3.up, curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode4, linenode5, new Vector3(linenode4.x, linenode5.y, 0), new Vector3(linenode4.x, linenode5.y, 0), curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode5, linenode6, linenode5 + Vector3.left, linenode6 + Vector3.right, curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode6, endPos, new Vector3(endPos.x, linenode6.y, 0), new Vector3(endPos.x, linenode6.y, 0), curvecolor, null, linewidth);
                    }
                    else
                    {
                        if (startPos.y + cornercurvelengthystart * 2 > endPos.y - cornercurvelengthyend * 2)
                        {
                            float halfstartend = headnowis ? 132f * clampzoom2 - 87f : 113.2f * clampzoom2 - 40.9f;
                            // float halfstartend = aSETnodesiListMouseClickIsSelected ? (newdepathNtypenodeListMouseClickIsSelected ? float.Parse(test2) : float.Parse(test1)) : float.Parse(test);
                            Vector3 linenode1 = new Vector3(startPos.x + cornercurvelengthx, startPos.y + halfstartend, 0);
                            Vector3 linenode2 = new Vector3(endPos.x - cornercurvelengthx, startPos.y + halfstartend, 0);
                            Handles.DrawBezier(startPos, linenode1, new Vector3(startPos.x, linenode1.y, 0), new Vector3(startPos.x, linenode1.y, 0), curvecolor, null, linewidth);
                            Handles.DrawBezier(linenode1, linenode2, linenode1 + Vector3.right, linenode2 + Vector3.left, curvecolor, null, linewidth);
                            Handles.DrawBezier(linenode2, endPos, new Vector3(endPos.x, linenode2.y, 0), new Vector3(endPos.x, linenode2.y, 0), curvecolor, null, linewidth);
                        }
                        else
                        {
                            Vector3 linenode1 = new Vector3(startPos.x + cornercurvelengthx, startPos.y + cornercurvelengthystart, 0);
                            Vector3 linenode2 = new Vector3(startPos.x + cornercurvelengthx + straightlinelength, startPos.y + cornercurvelengthystart, 0);
                            Vector3 linenode3 = new Vector3(startPos.x + cornercurvelengthx * 2 + straightlinelength, startPos.y + cornercurvelengthystart * 2, 0);
                            Vector3 linenode4 = new Vector3(startPos.x + cornercurvelengthx * 2 + straightlinelength, endPos.y - cornercurvelengthyend * 2, 0);
                            Vector3 linenode5 = new Vector3(startPos.x + cornercurvelengthx * 3 + straightlinelength, endPos.y - cornercurvelengthyend, 0);
                            Vector3 linenode6 = new Vector3(endPos.x - cornercurvelengthx, endPos.y - cornercurvelengthyend, 0);
                            Handles.DrawBezier(startPos, linenode1, new Vector3(startPos.x, linenode1.y, 0), new Vector3(startPos.x, linenode1.y, 0), curvecolor, null, linewidth);
                            Handles.DrawBezier(linenode1, linenode2, linenode1 + Vector3.right, linenode2 + Vector3.left, curvecolor, null, linewidth);
                            Handles.DrawBezier(linenode2, linenode3, new Vector3(linenode3.x, linenode2.y, 0), new Vector3(linenode3.x, linenode2.y, 0), curvecolor, null, linewidth);
                            Handles.DrawBezier(linenode3, linenode4, linenode3 + Vector3.down, linenode4 + Vector3.up, curvecolor, null, linewidth);
                            Handles.DrawBezier(linenode4, linenode5, new Vector3(linenode4.x, linenode5.y, 0), new Vector3(linenode4.x, linenode5.y, 0), curvecolor, null, linewidth);
                            Handles.DrawBezier(linenode5, linenode6, linenode5 + Vector3.right, linenode6 + Vector3.left, curvecolor, null, linewidth);
                            Handles.DrawBezier(linenode6, endPos, new Vector3(endPos.x, linenode6.y, 0), new Vector3(endPos.x, linenode6.y, 0), curvecolor, null, linewidth);

                        }

                    }
                }
                else
                {
                    if (isrightrow)
                    {
                        Vector3 linenode1 = new Vector3(startPos.x - cornercurvelengthx, startPos.y + cornercurvelengthystart, 0);
                        Vector3 linenode2 = new Vector3(startPos.x - cornercurvelengthx - straightlinelength, startPos.y + cornercurvelengthystart, 0);
                        Vector3 linenode3 = new Vector3(startPos.x - cornercurvelengthx * 2 - straightlinelength, startPos.y, 0);
                        Vector3 linenode4 = new Vector3(startPos.x - cornercurvelengthx * 2 - straightlinelength, endPos.y, 0);
                        Vector3 linenode5 = new Vector3(startPos.x - cornercurvelengthx * 3 - straightlinelength, endPos.y - cornercurvelengthyend, 0);
                        Vector3 linenode6 = new Vector3(endPos.x + cornercurvelengthx, endPos.y - cornercurvelengthyend, 0);
                        Handles.DrawBezier(startPos, linenode1, new Vector3(startPos.x, linenode1.y, 0), new Vector3(startPos.x, linenode1.y, 0), curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode1, linenode2, linenode1 + Vector3.left, linenode2 + Vector3.right, curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode2, linenode3, new Vector3(linenode3.x, linenode2.y, 0), new Vector3(linenode3.x, linenode2.y, 0), curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode3, linenode4, linenode3 + Vector3.up, linenode4 + Vector3.down, curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode4, linenode5, new Vector3(linenode4.x, linenode5.y, 0), new Vector3(linenode4.x, linenode5.y, 0), curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode5, linenode6, linenode5 + Vector3.left, linenode6 + Vector3.right, curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode6, endPos, new Vector3(endPos.x, linenode6.y, 0), new Vector3(endPos.x, linenode6.y, 0), curvecolor, null, linewidth);

                    }
                    else
                    {
                        Vector3 linenode1 = new Vector3(startPos.x + cornercurvelengthx, startPos.y + cornercurvelengthystart, 0);
                        Vector3 linenode2 = new Vector3(startPos.x + cornercurvelengthx + straightlinelength, startPos.y + cornercurvelengthystart, 0);
                        Vector3 linenode3 = new Vector3(startPos.x + cornercurvelengthx * 2 + straightlinelength, startPos.y, 0);
                        Vector3 linenode4 = new Vector3(startPos.x + cornercurvelengthx * 2 + straightlinelength, endPos.y, 0);
                        Vector3 linenode5 = new Vector3(startPos.x + cornercurvelengthx * 3 + straightlinelength, endPos.y - cornercurvelengthyend, 0);
                        Vector3 linenode6 = new Vector3(endPos.x - cornercurvelengthx, endPos.y - cornercurvelengthyend, 0);
                        Handles.DrawBezier(startPos, linenode1, new Vector3(startPos.x, linenode1.y, 0), new Vector3(startPos.x, linenode1.y, 0), curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode1, linenode2, linenode1 + Vector3.right, linenode2 + Vector3.left, curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode2, linenode3, new Vector3(linenode3.x, linenode2.y, 0), new Vector3(linenode3.x, linenode2.y, 0), curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode3, linenode4, linenode3 + Vector3.up, linenode4 + Vector3.down, curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode4, linenode5, new Vector3(linenode4.x, linenode5.y, 0), new Vector3(linenode4.x, linenode5.y, 0), curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode5, linenode6, linenode5 + Vector3.right, linenode6 + Vector3.left, curvecolor, null, linewidth);
                        Handles.DrawBezier(linenode6, endPos, new Vector3(endPos.x, linenode6.y, 0), new Vector3(endPos.x, linenode6.y, 0), curvecolor, null, linewidth);

                    }
                }
            }
        }

        if (!EditorGUIUtility.isProSkin)
        {
            GUI.color = curvecolor + new Color(0.2f, 0.2f, 0.2f, 0.0f);
        }
        if (headnowis)
        {
            float hundredbias = 100 / clampzoom2;
            float hundred20bias = 120 / clampzoom2;
            Rect labeltempboxrect = new Rect(startPos.x - hundred20bias / 2, startPos.y, hundred20bias, 22.5f / clampzoom2);
            if (-labeltempboxrect.x < labeltempboxrect.width && -labeltempboxrect.y < labeltempboxrect.height)
            {
                if (labeltempboxrect.x < (position.width - 8) / _zoom && labeltempboxrect.y < (position.height - 62f) / _zoom)
                {
                    if (!EditorGUIUtility.isProSkin)
                    {
                        GUI.Label(labeltempboxrect, string.Empty, "ShurikenEffectBg");
                    }
                    else
                    {
                        GUIStyle linenode = new GUIStyle();
                        linenode.normal.background = MakeTex(1, 1, curvecolor);
                        GUI.Label(labeltempboxrect, string.Empty, linenode);
                    }
                }
            }
            Rect labeltempboxrect2 = new Rect(endPos.x - hundredbias / 2, endPos.y, hundredbias, 20 / clampzoom2);
            if (-labeltempboxrect2.x < labeltempboxrect2.width && -labeltempboxrect2.y < labeltempboxrect2.height)
            {
                if (labeltempboxrect2.x < (position.width - 8) / _zoom && labeltempboxrect2.y < (position.height - 62f) / _zoom)
                {
                    if (!EditorGUIUtility.isProSkin)
                    {
                        GUI.Label(labeltempboxrect2, string.Empty, "ShurikenEffectBg");
                    }
                    else
                    {
                        GUIStyle linenode = new GUIStyle();
                        linenode.normal.background = MakeTex(1, 1, curvecolor);
                        GUI.Label(labeltempboxrect2, string.Empty, linenode);
                    }
                }
            }
        }
        else
        {
            float hundredbias = 100 / clampzoom2;
            Rect labeltempboxrect = new Rect(startPos.x - hundredbias / 2, startPos.y, hundredbias, 20 / clampzoom2);
            if (-labeltempboxrect.x < labeltempboxrect.width && -labeltempboxrect.y < labeltempboxrect.height)
            {
                if (labeltempboxrect.x < (position.width - 8) / _zoom && labeltempboxrect.y < (position.height - 62f) / _zoom)
                {
                    if (!EditorGUIUtility.isProSkin)
                    {

                        GUI.Label(labeltempboxrect, string.Empty, "ShurikenEffectBg");
                    }
                    else
                    {
                        GUIStyle linenode = new GUIStyle();
                        linenode.normal.background = MakeTex(1, 1, curvecolor);
                        GUI.Label(labeltempboxrect, string.Empty, linenode);
                    }

                }
            }
            Rect labeltempboxrect2 = new Rect(endPos.x - hundredbias / 2, endPos.y, hundredbias, 20 / clampzoom2);
            if (-labeltempboxrect2.x < labeltempboxrect2.width && -labeltempboxrect2.y < labeltempboxrect2.height)
            {
                if (labeltempboxrect2.x < (position.width - 8) / _zoom && labeltempboxrect2.y < (position.height - 62f) / _zoom)
                {
                    if (!EditorGUIUtility.isProSkin)
                    {
                        GUI.Label(labeltempboxrect2, string.Empty, "ShurikenEffectBg");
                    }
                    else
                    {
                        GUIStyle linenode = new GUIStyle();
                        linenode.normal.background = MakeTex(1, 1, curvecolor);
                        GUI.Label(labeltempboxrect2, string.Empty, linenode);
                    }
                }
            }
        }
        GUI.color = Color.white;
    }
    private int shiftfirst = 0;         //记录所选索引
    private List<string> selectedtypetemp = new List<string>();
    private void Singlemultiselect(int listindex, string currentype)       //单多选
    {
        string aswfnqlist = currentype + listindex;
        Event ec = Event.current;         //Update或OnGUI()
        if (ec.control)
        {
            if (currentSelectedIndex.Contains(aswfnqlist))
            {
                currentSelectedIndex.Remove(aswfnqlist);
            }
            else
            {
                currentSelectedIndex.Add(aswfnqlist);
            }
            shiftfirst = listindex;
            shiftcontinue = shiftcontinue2 = 0;
        }
        else if (ec.shift)
        {
            if (currentSelectedIndex[currentSelectedIndex.Count - 1].StartsWith(currentype))
            {
                if (shiftcontinue > 0)
                {
                    if (shiftfirst < shiftcontinue2)
                    {
                        if (shiftfirst <= listindex)
                        {
                            if (shiftcontinue2 < listindex)  //012
                            {
                                for (int i = shiftcontinue2; i <= listindex; i++)
                                {
                                    string aswfnqlisti = currentype + i;
                                    if (!currentSelectedIndex.Contains(aswfnqlisti))
                                        currentSelectedIndex.Add(aswfnqlisti);
                                }
                            }
                            else    //021
                            {
                                for (int i = listindex + 1; i <= shiftcontinue2; i++)
                                {
                                    string aswfnqlisti = currentype + i;
                                    currentSelectedIndex.Remove(aswfnqlisti);
                                }
                            }
                        }
                        else
                        {
                            for (int i = listindex; i < shiftfirst; i++) //201
                            {
                                string aswfnqlisti = currentype + i;
                                if (!currentSelectedIndex.Contains(aswfnqlisti))
                                    currentSelectedIndex.Add(aswfnqlisti);
                            }
                            shiftfirst = shiftcontinue2;
                        }
                    }
                    else
                    {
                        if (shiftfirst < listindex)  //102
                        {
                            for (int i = shiftfirst; i <= listindex; i++)
                            {
                                string aswfnqlisti = currentype + i;
                                if (!currentSelectedIndex.Contains(aswfnqlisti))
                                    currentSelectedIndex.Add(aswfnqlisti);
                            }
                            shiftfirst = shiftcontinue2;
                        }
                        else
                        {
                            if (shiftcontinue2 < listindex)  //120
                            {
                                for (int i = shiftcontinue2; i < listindex; i++)
                                {
                                    string aswfnqlisti = currentype + i;
                                    currentSelectedIndex.Remove(aswfnqlisti);
                                }
                            }
                            else       //210
                            {
                                for (int i = listindex; i <= shiftcontinue2; i++)
                                {
                                    string aswfnqlisti = currentype + i;
                                    if (!currentSelectedIndex.Contains(aswfnqlisti))
                                        currentSelectedIndex.Add(aswfnqlisti);
                                }
                            }
                        }
                    }
                }
                else
                {
                    if (shiftfirst < listindex)
                    {
                        for (int i = shiftfirst; i <= listindex; i++)
                        {
                            string aswfnqlisti = currentype + i;
                            if (!currentSelectedIndex.Contains(aswfnqlisti))
                                currentSelectedIndex.Add(aswfnqlisti);
                        }
                    }
                    else
                    {
                        for (int i = shiftfirst; i >= listindex; i--)
                        {
                            string aswfnqlisti = currentype + i;
                            if (!currentSelectedIndex.Contains(aswfnqlisti))
                                currentSelectedIndex.Add(aswfnqlisti);
                        }
                    }
                }
                shiftcontinue2 = listindex;
                shiftcontinue++;
            }
        }
        else
        {
            currentSelectedIndex.Clear();
            currentSelectedIndex.Add(aswfnqlist);
            selectedtypetemp.Clear();
            shiftcontinue = shiftcontinue2 = 0;
            shiftfirst = listindex;
        }
    }
    private void MyCustomToggle2(string i, bool ISListHeadnpn)      //选择勾白色框计算
    {
        ASETnode asetnodei = aSETnodes[i];
        // Rect outputListIsSelectedrect = (asetnodei.ListMouseClickIsSelected && ISListHeadnpn) ? new Rect(whiteBG.x, whiteBG.y, outerselectedfontsize, outerselectedfontsize) : new Rect(elepos.x, elepos.y, outerselectedfontsize, outerselectedfontsize);
        // if (Event.current.type == EventType.MouseDown && Event.current.button == 0)
        // {
        //     ismouseclickdown = false;
        // }
        // else if (Event.current.type == EventType.MouseUp && Event.current.button == 0)
        // {
        //     ismouseclickdown = true;
        // }
        // Rect newoutputListIsSelectedrect = new Rect(outputListIsSelectedrect.x + (ISListHeadnpn ? float.Parse(test) : float.Parse(test1)), outputListIsSelectedrect.y + (ISListHeadnpn ? float.Parse(test2) : float.Parse(test3)), outputListIsSelectedrect.width / clampzoom3, outputListIsSelectedrect.height / clampzoom3);
        // aSETnodes[i].outerclickwhiteboxgrid = newoutputListIsSelectedrect;
        Rect newoutputListIsSelectedrect = asetnodei.outerclickwhiteboxgrid;          //声明一个rect换上面这一大串的计算，还是比较划算的

        if (newoutputListIsSelectedrect.Contains(Event.current.mousePosition))
        {
            if (currentSelectedIndex.Count > 1 && ISListHeadnpn)
            {
                bool isshiftseleted = false;
                List<Rect> shiftmouserect = new List<Rect>();
                foreach (string q in aSETnodes.Keys)
                {
                    ASETnode asetnodevalq = aSETnodes[q];
                    string asetnodetype = q.Substring(q.LastIndexOf(stringspace) + 1);
                    string aswfnqiasetj = asetnodetype + asetnodevalq.asetindex;
                    if (currentSelectedIndex.Contains(aswfnqiasetj))
                    {
                        // Rect asetnodrec = asetnodevalq.ListRectPos;
                        // string asetnodepathtemp = q.Substring(0, q.LastIndexOf(stringspace));
                        // Rect whiteBGtemp = new Rect(asetnodrec.x - magitimerfunc, asetnodrec.y - magitimerfunc, asetnodrec.width * magitimer, asetnodrec.height * magitimer);
                        // Rect outputListIsSelectedrectemp = (aSETnodes[q].ListMouseClickIsSelected && ListHeadClickSeleted.Contains(asetnodepathtemp)) ? new Rect(whiteBGtemp.x, whiteBGtemp.y, outerselectedfontsize, outerselectedfontsize) : new Rect(asetnodrec.x, asetnodrec.y, outerselectedfontsize, outerselectedfontsize);
                        // Rect shiftmouseclick = new Rect(outputListIsSelectedrectemp.x + 4, outputListIsSelectedrectemp.y - 11f, outputListIsSelectedrect.width, outputListIsSelectedrect.height);
                        // if (shiftmouseclick.Contains(Event.current.mousePosition))
                        Rect asetnodevalqouterclickwhiteboxgridtemp = asetnodevalq.outerclickwhiteboxgrid;      //声明一个rect换上面这一大串的计算，还是比较划算的
                        if (asetnodevalqouterclickwhiteboxgridtemp.Contains(Event.current.mousePosition))
                        {
                            isshiftseleted |= true;
                        }
                        if (!shiftmouserect.Contains(asetnodevalqouterclickwhiteboxgridtemp))
                        {
                            Clickdownoutputlistselected(q, asetnodei.outputListIsSelected);
                            shiftmouserect.Add(asetnodevalqouterclickwhiteboxgridtemp);
                        }

                        for (int k = 0; k < asetnodevalq.ListDenpend.Count; k++)
                        {
                            string aqldk = asetnodevalq.ListDenpend[k];
                            ASETnode asetnodevalqDepend = aSETnodes[aqldk];
                            // Rect asetnodrecDenpend = asetnodevalqDepend.ListRectPos;
                            // string asetnodepathtempDenpend = q.Substring(0, q.LastIndexOf(stringspace));
                            // Rect whiteBGtempDenpend = new Rect(asetnodrecDenpend.x - magitimerfunc, asetnodrecDenpend.y - magitimerfunc, asetnodrecDenpend.width * magitimer, asetnodrecDenpend.height * magitimer);
                            // Rect outputListIsSelectedrectempDenpend = (aSETnodes[q].ListMouseClickIsSelected && ListHeadClickSeleted.Contains(asetnodepathtempDenpend)) ? new Rect(whiteBGtempDenpend.x, whiteBGtempDenpend.y, outerselectedfontsize, outerselectedfontsize) : new Rect(asetnodrecDenpend.x, asetnodrecDenpend.y, outerselectedfontsize, outerselectedfontsize);
                            // Rect shiftmouseclickDenpend = new Rect(outputListIsSelectedrectempDenpend.x + 4, outputListIsSelectedrectempDenpend.y - 11f, outputListIsSelectedrect.width, outputListIsSelectedrect.height);
                            if (!shiftmouserect.Contains(asetnodevalqDepend.outerclickwhiteboxgrid))          //声明一个rect换上面这一大串的计算，还是比较划算的
                            {
                                Clickdownoutputlistselected(aqldk, asetnodei.outputListIsSelected);
                                shiftmouserect.Add(asetnodevalqDepend.outerclickwhiteboxgrid);
                            }
                        }
                    }
                    if (isshiftseleted)
                    {
                        for (int a = 0; a < shiftmouserect.Count; a++)
                        {
                            if (iconisexist)
                            {
                                DrawLineFrame(shiftmouserect[a], new Color(0.9f, 0.9f, 0.9f, 1.0f), 1 / _zoom);
                            }
                            else
                            {
                                GUI.skin = GUISKINIcons;
                                GUIStyle whiteboxrect = new GUIStyle("label");
                                int whiteboxratio = (int)Mathf.Clamp(115.28f / _zoom - 394.25f, 0, 52);
                                // whiteboxrect.border = new RectOffset(int.Parse(test), int.Parse(test), int.Parse(test), int.Parse(test));
                                whiteboxrect.border = new RectOffset(whiteboxratio, whiteboxratio, whiteboxratio, whiteboxratio);
                                // UnityEngine.Debug.Log(_zoom);
                                // UnityEngine.Debug.Log(1 / _zoom);

                                // float oputsdtimer = 1.1f;
                                // float oputsdtimer1 = 0.5f * oputsdtimer - 0.5f;
                                // Rect new1newoutputListIsSelectedrect = new Rect(shiftmouserect[a].x - shiftmouserect[a].width * oputsdtimer1, shiftmouserect[a].y - shiftmouserect[a].height * oputsdtimer1, shiftmouserect[a].width * oputsdtimer, shiftmouserect[a].height * oputsdtimer);
                                // GUI.Box(new1newoutputListIsSelectedrect, string.Empty, whiteboxrect);
                                GUI.Box(shiftmouserect[a], string.Empty, whiteboxrect);
                                GUI.skin = null;
                            }
                        }
                    }
                    else
                    {
                        if (iconisexist)
                        {
                            DrawLineFrame(newoutputListIsSelectedrect, new Color(0.9f, 0.9f, 0.9f, 1.0f), 1 / _zoom);
                        }
                        else
                        {
                            GUI.skin = GUISKINIcons;
                            GUIStyle whiteboxrect = new GUIStyle("label");
                            int whiteboxratio = (int)Mathf.Clamp(115.28f / _zoom - 394.25f, 0, 52);
                            // whiteboxrect.border = new RectOffset(int.Parse(test), int.Parse(test), int.Parse(test), int.Parse(test));
                            whiteboxrect.border = new RectOffset(whiteboxratio, whiteboxratio, whiteboxratio, whiteboxratio);
                            // UnityEngine.Debug.Log(_zoom);
                            // UnityEngine.Debug.Log(1 / _zoom);

                            // float oputsdtimer = 1.1f;
                            // float oputsdtimer1 = 0.5f * oputsdtimer - 0.5f;
                            // Rect new1newoutputListIsSelectedrect = new Rect(newoutputListIsSelectedrect.x - newoutputListIsSelectedrect.width * oputsdtimer1, newoutputListIsSelectedrect.y - newoutputListIsSelectedrect.height * oputsdtimer1, newoutputListIsSelectedrect.width * oputsdtimer, newoutputListIsSelectedrect.height * oputsdtimer);
                            // GUI.Box(new1newoutputListIsSelectedrect, string.Empty, whiteboxrect);
                            GUI.Box(newoutputListIsSelectedrect, string.Empty, whiteboxrect);
                            GUI.skin = null;
                        }
                    }
                }
            }
            else
            {
                if (iconisexist)
                {
                    DrawLineFrame(newoutputListIsSelectedrect, new Color(0.9f, 0.9f, 0.9f, 1.0f), 1 / _zoom);
                }
                else
                {
                    GUI.skin = GUISKINIcons;
                    GUIStyle whiteboxrect = new GUIStyle("label");
                    int whiteboxratio = (int)Mathf.Clamp(115.28f / _zoom - 394.25f, 0, 52);
                    // whiteboxrect.border = new RectOffset(int.Parse(test), int.Parse(test), int.Parse(test), int.Parse(test));
                    whiteboxrect.border = new RectOffset(whiteboxratio, whiteboxratio, whiteboxratio, whiteboxratio);
                    // UnityEngine.Debug.Log(_zoom);
                    // UnityEngine.Debug.Log(1 / _zoom);

                    // float oputsdtimer = 1.1f;
                    // float oputsdtimer1 = 0.5f * oputsdtimer - 0.5f;
                    // Rect new1newoutputListIsSelectedrect = new Rect(newoutputListIsSelectedrect.x - newoutputListIsSelectedrect.width * oputsdtimer1, newoutputListIsSelectedrect.y - newoutputListIsSelectedrect.height * oputsdtimer1, newoutputListIsSelectedrect.width * oputsdtimer, newoutputListIsSelectedrect.height * oputsdtimer);
                    // GUI.Box(new1newoutputListIsSelectedrect, string.Empty, whiteboxrect);
                    GUI.Box(newoutputListIsSelectedrect, string.Empty, whiteboxrect);
                    GUI.skin = null;
                }
                if (ISListHeadnpn)
                {
                    Drawlineframedepend(asetnodei);
                }
            }
            GUI.changed = true;
        }
    }
    private void Clickdownoutputlistselected(string ail, bool outputlist)
    {
        if (Event.current.type == EventType.MouseDown && Event.current.button == 0)
        {
            aSETnodes[ail].outputListIsSelected = outputlist;
        }
    }
    private void Drawlineframedepend(ASETnode asetnodei)          //如果选择勾主节点，依赖节点也同时选择
    {
        for (int k = 0; k < asetnodei.ListDenpend.Count; k++)
        {
            string aildk = asetnodei.ListDenpend[k];
            ASETnode asetnodevalqDepend = aSETnodes[aildk];
            if (iconisexist)
            {
                DrawLineFrame(asetnodevalqDepend.outerclickwhiteboxgrid, new Color(0.9f, 0.9f, 0.9f, 1.0f), 1 / _zoom);
            }
            else
            {
                GUI.skin = GUISKINIcons;
                GUIStyle whiteboxrect = new GUIStyle("label");
                int whiteboxratio = (int)Mathf.Clamp(115.28f / _zoom - 394.25f, 0, 52);
                // whiteboxrect.border = new RectOffset(int.Parse(test), int.Parse(test), int.Parse(test), int.Parse(test));
                whiteboxrect.border = new RectOffset(whiteboxratio, whiteboxratio, whiteboxratio, whiteboxratio);
                // UnityEngine.Debug.Log(_zoom);
                // UnityEngine.Debug.Log(1 / _zoom);

                // float oputsdtimer = 1.1f;
                // float oputsdtimer1 = 0.5f * oputsdtimer - 0.5f;
                // Rect new1newoutputListIsSelectedrect = new Rect(asetnodevalqDepend.outerclickwhiteboxgrid.x - asetnodevalqDepend.outerclickwhiteboxgrid.width * oputsdtimer1, asetnodevalqDepend.outerclickwhiteboxgrid.y - asetnodevalqDepend.outerclickwhiteboxgrid.height * oputsdtimer1, asetnodevalqDepend.outerclickwhiteboxgrid.width * oputsdtimer, asetnodevalqDepend.outerclickwhiteboxgrid.height * oputsdtimer);
                // GUI.Box(new1newoutputListIsSelectedrect, string.Empty, whiteboxrect);
                GUI.Box(asetnodevalqDepend.outerclickwhiteboxgrid, string.Empty, whiteboxrect);
                GUI.skin = null;
            }
            Clickdownoutputlistselected(aildk, asetnodei.outputListIsSelected);
            Drawlineframedepend(aSETnodes[aildk]);
        }
    }

    private void Loopdepend(string i, Rect kvprect, float clampzoom, string nowpathname1, float clampzoom2)     //寻找依赖中的依赖
    {
        ASETnode asetnodeval = aSETnodes[i];
        for (int k = 0; k < asetnodeval.ListDenpend.Count; k++)
        {
            string depathNType = asetnodeval.ListDenpend[k];
            string depath = depathNType.Substring(0, depathNType.LastIndexOf(stringspace));
            ASETnode newdepathNtypenode = aSETnodes[depathNType];

            aSETnodes[depathNType].ListMouseClickIsSelected = true;
            selectedtypetemp.Add(depathNType);

            Rect BCNLCome = newdepathNtypenode.ListRectPos;
            float colorbalance = EditorGUIUtility.isProSkin ? 0.9f : 0.1f;
            Color colorb = new Color(colorbalance, colorbalance, colorbalance, UselessMatexModel.Contains(depathNType) || UselessMatexModel.Contains(i) ? 0.15f : 1f);
            DrawNodeCurve(kvprect, BCNLCome, 8 / clampzoom, colorb, nowpathname1, clampzoom2);
            Loopdepend(depathNType, newdepathNtypenode.ListRectPos, clampzoom, depath, clampzoom2);
        }
    }
    private void PackageExport(string finalstring, List<string> outputnewPathList, List<string> outputoldPathList, bool cscountgreat0, bool isRMSexist, ref Dictionary<string, bool> isfinalstringexist)
    {
        string exportfoldername = System.IO.Path.GetFileName(finalstring);
        string path = EditorUtility.SaveFilePanel("Package Export", "", exportfoldername, "unitypackage");
        if (path == string.Empty)
        {
            ReturnAndDeleteFile(outputnewPathList, outputoldPathList, finalstring, isRMSexist, ref isfinalstringexist);
            if (cscountgreat0)
            {
                EditorUtility.DisplayDialog("Notification", "The Export files include scripts, but you cancel exporting selected files\n\nTo ensure the program keep working, the Assets Sorting Exporter will close and you will need to reselect the package file\n", "OK");
            }
        }
        else
        {
            AssetDatabase.ExportPackage(outputnewPathList.ToArray(), path, ExportPackageOptions.Recurse);
            ReturnAndDeleteFile(outputnewPathList, outputoldPathList, finalstring, isRMSexist, ref isfinalstringexist);
            if (cscountgreat0)
            {
                IsScriptExistNotification();
            }
        }
    }
    private void IsScriptExistNotification()
    {
        EditorUtility.DisplayDialog("Notification", "The Export files include scripts\n\nTo ensure the program keep working, the Assets Sorting Exporter will close", "OK");
    }

    private void NotiReturn(List<string> outputnewPathList, List<string> outputoldPathList, string finalstring, int cscountouterselected, bool ispsgreat0, ref Dictionary<string, bool> isfinalstringexist)
    {
        bool cscountgreat0 = cscountouterselected > 0;
        if (outputnewPathList.Count == 0)
        {
            // EditorUtility.DisplayDialog("Notification", "No Files Selected", "OK");
            ShowNotification(new GUIContent("No Files Selected!"), 2.0f);
            if (isfinalstringexist[finalstring])
            {
                Deletecore(finalstring);
            }
        }
        else
        {
            if (!isfinalstringexist[finalstring])
            {
                int option0 = EditorUtility.DisplayDialogComplex("Notification", "The folder name to export already exists in the project\n\nSelect Yes to move files to this folder\n\nSelect No to Pack files Only\n\nSelect Cancel or close this notification to Return\n", "Yes", "No", "Cancel");
                switch (option0)
                {
                    case 0:
                        {
                            int j = 0;
                            Dictionary<string, ASETnode> asetnodetemp = new Dictionary<string, ASETnode>();
                            foreach (string i in aSETnodes.Keys)
                            {
                                ASETnode aseti = aSETnodes[i];
                                if (i.StartsWith(outputoldPathList[j]))
                                {
                                    int stringspaceindex = i.LastIndexOf(stringspace);
                                    string nowpathname1 = i.Substring(0, stringspaceindex);
                                    string newi = i.Replace(nowpathname1, outputnewPathList[j]);
                                    asetnodetemp.Add(newi, aseti);
                                    j++;
                                }
                                else
                                {
                                    asetnodetemp.Add(i, aseti);
                                }
                            }
                            aSETnodes = asetnodetemp;
                            if (cscountgreat0)
                            {
                                IsScriptExistNotification();
                            }
                        }
                        return;
                    case 1:
                        {
                            PackageExport(finalstring, outputnewPathList, outputoldPathList, cscountgreat0, false, ref isfinalstringexist);
                        }
                        return;
                    case 2:
                        {
                            ReturnAndDeleteFile(outputnewPathList, outputoldPathList, finalstring, false, ref isfinalstringexist);
                            if (cscountgreat0)
                            {
                                IsScriptExistNotification();
                            }
                        }
                        return;
                }
            }
            else
            {
                if (ispsgreat0)
                {
                    int option = EditorUtility.DisplayDialogComplex("Notification", "The Export files include missing scripts——\n\nSelect Yes to generate a script named RemoveMissingScripts.cs for Removing Missing Scripts\n\nSelect No to keep missing scripts\n\nSelect Cancel or close this notification to Return\n", "Yes", "No", "Cancel");
                    switch (option)
                    {
                        case 0:
                            {
                                GenerateRMS(finalstring, out string Mo_p____qE);
                                outputnewPathList.Add(Mo_p____qE);
                                cscountouterselected++;
                                cscountgreat0 = cscountouterselected > 0;
                                PackageExport(finalstring, outputnewPathList, outputoldPathList, cscountgreat0, true, ref isfinalstringexist);
                            }
                            return;
                        case 1:
                            {
                                PackageExport(finalstring, outputnewPathList, outputoldPathList, cscountgreat0, false, ref isfinalstringexist);
                            }
                            return;
                        case 2:
                            {
                                ReturnAndDeleteFile(outputnewPathList, outputoldPathList, finalstring, false, ref isfinalstringexist);
                                if (cscountgreat0)
                                {
                                    IsScriptExistNotification();
                                }
                            }
                            return;
                    }
                }
                else
                {
                    PackageExport(finalstring, outputnewPathList, outputoldPathList, cscountgreat0, false, ref isfinalstringexist);
                }
            }
        }
    }
    private float eleposnowtemptime = 0.0f;
    private void ShownodeLine(ref int selectedCount, bool exportrue, List<Vector2> typenamelist)
    {
        Dictionary<string, int> outputPathsamepath = new Dictionary<string, int>();     //打包后碰到同名文件新建文件夹相关
        List<string> outputnewPathList = new List<string>();    //打包后新路径
        List<string> outputoldPathList = new List<string>();    //打包后旧路径
        Dictionary<string, bool> isfinalstringexist = new Dictionary<string, bool>();   //打包后检测文件夹是否存在
        List<string> prefabNscenelist = new List<string>();     //所选文件中prefab和scene的路径
        int cscountouterselected = 0;   //所选文件中脚本的数量
        string finalstring = ASWFolderNames[21] + stringslash + myString;   //导出路径


        float clampzoom = Mathf.Clamp(_zoom, 0.25f, 1f);
        float clampzoom2 = Mathf.Clamp(_zoom, 0.75f, 1f);
        float clampzoom3 = Mathf.Clamp(_zoom, 0.5f, 1f);

        /**********************高亮头文件选中重置****************/
        float zoomdivideheighthead = int.MaxValue;
        float zoomdividewidthhead = int.MaxValue;
        float zoomdivideheighthead2 = int.MinValue;
        float zoomdividewidthhead2 = int.MinValue;
        float zoomdividewidthcurrent = 0;
        Vector2 elepos0temp = Vector2.zero;
        bool eleposisfirst = true;
        Vector2 eleposnowtemp = Vector2.zero;
        float eleposnowtemptime0 = 1f;
        float eleposnowtemptime1 = 3f;
        /*******************************/

        /**********种类名称初始化************/
        int intypecountindex = 0;
        string GUInowtypename = string.Empty;
        /*******************************/

        /*************检测导出文件夹是否存在******************/
        isfinalstringexist.Add(finalstring, !Directory.Exists(finalstring));
        if (!Directory.Exists(finalstring) && exportrue)
        {
            Createdirectory1(finalstring);
        }
        /*******************************/

        foreach (string i in aSETnodes.Keys)
        {
            ASETnode asetnodeval = aSETnodes[i];
            string nowtypename1 = i.Substring(i.LastIndexOf(stringspace) + 1);
            string nowpathname1 = i.Substring(0, i.LastIndexOf(stringspace));
            string aswfnq = nowtypename1 + asetnodeval.asetindex;
            bool ISListHeadnpn = ListHeadClickSeleted.Contains(nowpathname1);

            /*************选择勾白色框Rect计算相关******************/
            MyCustomToggle2(i, ISListHeadnpn);
            /*******************************/

            Rect asetrect = aSETnodes[i].ListRectPos;
            if (currentSelectedIndex.Contains(aswfnq))
            {
                Rect kvprect = asetnodeval.ListRectPos;

                /**************连线相关*****************/
                Loopdepend(i, kvprect, clampzoom, nowpathname1, clampzoom2);
                /*******************************/

                /***************高亮头文件选中重置时间计算****************/
                // if ((Event.current.type == EventType.MouseUp || Event.current.type == EventType.MouseDown) && Event.current.button == 0)
                if (clickcountime > 0.9f)
                {
                    // float asetrectimerwh = 2f;
                    // float asetrectimerxy = 0.5f * asetrectimerwh - 0.5f;
                    // Rect newasetrect = new Rect(asetrect.x - asetrect.width * asetrectimerxy, asetrect.y - asetrect.height * asetrectimerxy, asetrect.width * asetrectimerwh, asetrect.height * asetrectimerwh);
                    // // GUI.Box(newasetrect, "asidoja");
                    // if (!aSETnodes[i].outerclickwhiteboxgrid.Contains(Event.current.mousePosition) && newasetrect.Contains(Event.current.mousePosition))
                    if (!aSETnodes[i].outerclickwhiteboxgrid.Contains(Event.current.mousePosition))
                    {
                        eleposnowtemptime += eleposnowtemptime0;
                    }
                    GUI.changed = true;
                }
                /*******************************/
            }
            /*************统计场景预制体脚本数量，导出核心需要******************/
            if (asetnodeval.outputListIsSelected)
            {
                selectedCount++;
                if (nowtypename1 == ASWFolderNames[1] || nowtypename1 == ASWFolderNames[0])
                {
                    prefabNscenelist.Add(i);
                }
                if (nowtypename1 == ASWFolderNames[5])
                {
                    cscountouterselected++;
                }
            }
            /**************种类名称初始化*****************/
            bool issamenowtypename = GUInowtypename != nowtypename1;
            if (issamenowtypename)
            {
                int singletypecount = intypecount[intypecountindex];
                Vector2 typenamelistxy = typenamelist[intypecountindex];
                intypecountindex++;
                GUInowtypename = nowtypename1;
                Rect labeltempboxrect = new Rect(typenamelistxy.x + 10, typenamelistxy.y - 160f, 1500f, 160f);
                // GUI.Box(labeltempboxrect, string.Empty);
                if (-labeltempboxrect.x < labeltempboxrect.width && -labeltempboxrect.y < labeltempboxrect.height)
                {
                    if (labeltempboxrect.x < (position.width - 8) / _zoom && labeltempboxrect.y < (position.height - 62f) / _zoom)
                    {
                        GUIStyle fontsy = new GUIStyle();
                        fontsy.alignment = TextAnchor.LowerLeft;        //锚点放左下角
                        fontsy.fontSize = (int)(30 / clampzoom);
                        fontsy.fontStyle = FontStyle.Bold;

                        fontsy.normal.textColor = new Color(0.1f, 0.1f, 0.1f, 1f);      //搞个阴影
                        fontsy.contentOffset = Vector2.one * 3.5f / clampzoom;
                        GUI.Label(labeltempboxrect, nowtypename1 + " (" + singletypecount + ")", fontsy);

                        fontsy.contentOffset = Vector2.zero;
                        fontsy.normal.textColor = new Color(0.9f, 0.9f, 0.9f, 1f);
                        GUI.Label(labeltempboxrect, nowtypename1 + " (" + singletypecount + ")", fontsy);

                    }
                }
            }
            /*******************************/

            if (eleposisfirst)
            {
                elepos0temp = new Vector2(asetrect.x, asetrect.y);
                eleposisfirst = false;
            }
            if (aSETnodes[i].ListMouseClickIsSelected)
            {
                eleposnowtemp = new Vector2(asetrect.x, asetrect.y);
                zoomdividewidthcurrent++;
                zoomdivideheighthead = Mathf.Min(zoomdivideheighthead, asetrect.y);
                zoomdivideheighthead2 = Mathf.Max(zoomdivideheighthead2, asetrect.y);
                zoomdividewidthhead = Mathf.Min(zoomdividewidthhead, asetrect.x);
                zoomdividewidthhead2 = Mathf.Max(zoomdividewidthhead2, asetrect.x);
            }

            /************导出核心*******************/
            if (exportrue)
            {
                ExportCore(i, finalstring, nowtypename1, nowpathname1, ref outputnewPathList, ref outputoldPathList, ref outputPathsamepath, ref isfinalstringexist);
            }
            /*******************************/
        }

        /*************导出核心******************/
        if (exportrue)
        {
            AssetDatabase.Refresh();

            /******判断所选预制体或场景中，脚本是否选满******/
            int cscountouterselectedinpreNsce = 0;
            int cscountouterselectedinpreNsceall = 0;
            for (int m = 0; m < prefabNscenelist.Count; m++)
            {
                string prefabNscenelistm = prefabNscenelist[m];
                Iscsin(ref cscountouterselectedinpreNsce, ref cscountouterselectedinpreNsceall, prefabNscenelistm);
            }
            bool ispsgreat0 = cscountouterselectedinpreNsce < cscountouterselectedinpreNsceall;
            /*******************************/

            NotiReturn(outputnewPathList, outputoldPathList, finalstring, cscountouterselected, ispsgreat0, ref isfinalstringexist);
            AssetDatabase.Refresh();
        }
        /*******************************/


        /*************高亮头文件选中重置******************/
        if (eleposnowtemptime >= eleposnowtemptime0 && eleposnowtemptime < eleposnowtemptime1)
        {
            eleposnowtemptime += Time.deltaTime;
            GUI.changed = true;
        }
        else
        {
            eleposnowtemptime = 0.0f;
            GUI.changed = true;
        }
        float eleposnowtemptimehalf01 = (eleposnowtemptime1 - eleposnowtemptime0) / 2f;
        if (eleposnowtemptime >= eleposnowtemptimehalf01 && currentSelectedIndex.Count > 0)
        {
            float realheight = position.height - (25.5f + 62f);
            float realwidth = position.width - (4 + 8);
            if (zoomdividewidthcurrent > 1)
            {
                float zoomdivideheadrow2 = Mathf.Abs(zoomdividewidthhead2 - zoomdividewidthhead) + rowwidth + 300;
                float zoomdivideheadrow = zoomdivideheadrow2;
                float zoomdivideheadcolumn2 = Mathf.Abs(zoomdivideheighthead2 - zoomdivideheighthead) + columnheight + 300;
                float zoomdivideheadcolumn = zoomdivideheadcolumn2;
                _zoomCoordsOrigin = Vector2.zero;
                _zoom = Mathf.Min(1, realheight / zoomdivideheadcolumn, realwidth / zoomdivideheadrow);
                float zoomx = zoomdividewidthhead - elepos0temp.x - (realwidth / 2 / _zoom - zoomdivideheadrow2 / 2) - 180f;
                float zoomy = zoomdivideheighthead - elepos0temp.y - (realheight / 2 / _zoom - zoomdivideheadcolumn2 / 2) - (21.532f / _zoom + 123.95f);
                _zoomCoordsOrigin = new Vector2(zoomx, zoomy);
            }
            // else     //如果高光节点没有依赖节点的情况
            // {
            //     float _zoomtimer = 0.5f;
            //     _zoom = _zoomtimer;
            //     _zoomCoordsOrigin = new Vector2(-(position.width - (4 + 8) - rowwidth) / 2, -(position.height - (25.5f + 62f) - columnheight) / 2) * (1.25f / _zoomtimer);
            //     _zoomCoordsOrigin += eleposnowtemp - elepos0temp;
            // }
            GUI.changed = true;
        }
        /*******************************/
    }
    private void Iscsin(ref int cscountouterselectedinpreNsce, ref int cscountouterselectedinpreNsceall, string prefabNscenelistm)      //检查所选文件中脚本是否有漏选
    {
        List<string> prefabNscenelistmDepend = aSETnodes[prefabNscenelistm].ListDenpend;
        for (int n = 0; n < prefabNscenelistmDepend.Count; n++)
        {
            string prefabNscenelistmDependn = prefabNscenelistmDepend[n];
            string prefabNscenelistmDependname = prefabNscenelistmDependn.Substring(prefabNscenelistmDependn.LastIndexOf(stringspace) + 1);
            ASETnode prefabNscenelistmDependnaset = aSETnodes[prefabNscenelistmDependn];
            if (prefabNscenelistmDependname == ASWFolderNames[5])
            {
                cscountouterselectedinpreNsceall++;
                if (prefabNscenelistmDependnaset.outputListIsSelected)
                {
                    cscountouterselectedinpreNsce++;
                }
            }
            Iscsin(ref cscountouterselectedinpreNsce, ref cscountouterselectedinpreNsceall, prefabNscenelistmDependn);
        }
    }

    private static readonly int columny = 200;      //类型与类型之间的纵向距离
    private static readonly float columnysametype = 2f;     //node与node之间的纵向距离
    private static readonly int rowx = 300;     //node与node之间的横向距离
    private static readonly int rowwidth = 150;     //node宽
    private static readonly int columnheight = 150;     //node高

    private int clickcount = 0;     //鼠标点击计数
    private float clickcountime = 0;    //鼠标点击计数时间累计
    private bool Isreversedependent = false;    //是否进入被依赖的界面
    private class TypeBoxRectName
    {
        public Rect TBR;    //种类边框Rect
        public string TBRn;     //种类名
        public int TBR1typeMaxCount;     //一个种类下的文件数量
        public TypeBoxRectName(Rect A1, string B1, int C1)
        {
            TBR = A1;
            TBRn = B1;
            TBR1typeMaxCount = C1;
        }
    }
    private TypeBoxRectName[] allreverseboxrect;
    private class ASETRevesenode
    {
        public int asetindex;       //在该种类下的索引数
        public bool Isreversepress;       //该节点受否被鼠标按住
        public int SearchListindex;     //搜索状态下文件的搜索索引数
        public Rect ListRectPos;    //节点的Rect
        public ASETRevesenode(int A1, bool B1, int E1, Rect F1)
        {
            asetindex = A1;
            Isreversepress = B1;
            SearchListindex = E1;
            ListRectPos = F1;
        }
    }
    private Dictionary<string, ASETRevesenode> ReversedependentList = new Dictionary<string, ASETRevesenode>();    //被依赖文件的源头合集
    private void DpendendenCallback(object nowpathname)
    {
        Isreversedependent = true;
        ReversedependentList = new Dictionary<string, ASETRevesenode>();
        string nowpathname1 = nowpathname.ToString();
        Reversedepentlistadd(nowpathname1);
    }
    private void ScanReverseDepend(string allfilesinasseti, ref List<string> allfilesinassetemp, string nowpathname1, ref Dictionary<string, int> thistypecount)
    {
        string[] ldenpends = AssetDatabase.GetDependencies(allfilesinasseti, true);
        for (int i = 0; i < ldenpends.Length; i++)
        {
            string filePath = ldenpends[i];
            if (filePath.StartsWith(ASWFolderNames[21] + stringslash))
            {
                if (!allfilesinassetemp.Contains(filePath))
                {
                    allfilesinassetemp.Add(filePath);
                }
                if (filePath == nowpathname1)
                {
                    string allfilesinassetitype = ListClassified2(allfilesinasseti);

                    // int k = 0;
                    if (!thistypecount.ContainsKey(allfilesinassetitype))
                    {
                        thistypecount.Add(allfilesinassetitype, 0);
                        // k = thistypecount.Count - 1;
                    }
                    else
                    {
                        thistypecount[allfilesinassetitype]++;
                        foreach (string j in thistypecount.Keys)
                        {
                            if (j == allfilesinassetitype)
                            {
                                break;
                            }
                            // else
                            // {
                            //     k++;
                            // }
                        }
                    }
                    string asetreversekey = allfilesinasseti + stringspace + allfilesinassetitype;
                    // ReversedependentList.Add(asetreversekey, new ASETRevesenode(thistypecount[allfilesinassetitype], 0, new Rect(thistypecount[allfilesinassetitype] * rowx, k * float.Parse(test1), rowwidth, columnheight)));
                    ReversedependentList.Add(asetreversekey, new ASETRevesenode(thistypecount[allfilesinassetitype], true, 0, new Rect(0, 0, 1, 1)));
                }
            }
        }
    }
    private void Reversedepentlistadd(string nowpathname1)
    {

        /**********重置需要************/
        zoomstartvaluetime = 1.0f;
        /*******************************/

        /*********************收集项目中所有文件**********************/
        List<string> allfilesinasset = new List<string>();
        string[] allfilesinassetarray = Directory.GetFiles(ASWFolderNames[21], "*", SearchOption.AllDirectories);
        for (int qq = 0; qq < allfilesinassetarray.Length; qq++)
        {
            string allfilesinassetarrayqq = allfilesinassetarray[qq];
            if (!IsSuff(allfilesinassetarrayqq, Stringmeta))
            {
                string slashreplace = allfilesinassetarrayqq.Replace("\\", stringslash);
                allfilesinasset.Add(slashreplace);
            }
        }
        /********************************************************/

        /*********************收集依赖源头文件**********************/
        List<string> allfilesinassetemp = new List<string>();
        Dictionary<string, int> thistypecount = new Dictionary<string, int>();
        for (int i = 0; i < allfilesinasset.Count; i++)
        {
            string allfilesinasseti = allfilesinasset[i];
            if (!allfilesinassetemp.Contains(allfilesinasseti) && allfilesinasseti != nowpathname1)
            {
                ScanReverseDepend(allfilesinasseti, ref allfilesinassetemp, nowpathname1, ref thistypecount);
            }
        }

        if (ReversedependentList.Count == 0)
        {
            ShowNotification(new GUIContent("No Dependent source file!"), 2.0f);
            Isreversedependent = false;
            return;
        }
        /********************************************************/

        /*********************根据ASWFolderNames重新排列ReversedependentList**********************/
        List<string> thistypes = new List<string>(thistypecount.Keys);
        thistypes = SortTypeNode(ASWFolderNames, thistypes);//按照ASWFolderNames列表排序
        Dictionary<string, ASETRevesenode> ReversedependentListemp = new Dictionary<string, ASETRevesenode>();    //被依赖文件的源头合集temp
        for (int k = 0; k < thistypes.Count; k++)
        {
            string thistypek = thistypes[k];
            foreach (string i in ReversedependentList.Keys)
            {
                ASETRevesenode asetreversenode = ReversedependentList[i];
                int stringspaceindex = i.LastIndexOf(stringspace);
                string nowtypename1 = i.Substring(stringspaceindex + 1);    //type
                // string nowpathname2 = i.Substring(0, stringspaceindex);     //path
                if (nowtypename1 == thistypek)
                {
                    ReversedependentListemp.Add(i, asetreversenode);
                }
            }
        }
        ReversedependentList = ReversedependentListemp;
        /********************************************************/

        /*********************收集所有Rect**********************/
        allreverseboxrect = new TypeBoxRectName[thistypes.Count];      //种类边框Rect数组初始化
        for (int i = 0; i < allreverseboxrect.Length; i++)
        {
            allreverseboxrect[i] = new TypeBoxRectName(new Rect(0, 0, 1, 1), string.Empty, 0);
        }

        string GUInowtypename = string.Empty;
        float asj = 0;
        int allreverseboxrectindex = 0;
        float nodemaxCount = 0.0f;
        float asjfrontval = 0.0f;
        int typeMaxCount = 0;
        int accumulatetypeMaxCount = 0;
        foreach (string i in ReversedependentList.Keys)
        {
            ASETRevesenode asetreversenode = ReversedependentList[i];
            int asetreversenodeasetindex = asetreversenode.asetindex;
            int stringspaceindex = i.LastIndexOf(stringspace);
            string nowtypename1 = i.Substring(stringspaceindex + 1);    //type
            string nowpathname2 = i.Substring(0, stringspaceindex);     //path
            typeMaxCount = Mathf.Max(typeMaxCount, asetreversenodeasetindex + 1);

            /**************种类边框***************/
            bool issamenowtypename = GUInowtypename != nowtypename1;
            Rect elepos = new Rect(0, 0, 1, 1);
            if (issamenowtypename)
            {

                int thistypecountvalue = thistypecount[nowtypename1];
                int thistypecountvalue1 = thistypecountvalue + 1;
                float nodemaxCountype = thistypecountvalue1 > 21 ? Mathf.Ceil(Mathf.Sqrt(thistypecountvalue1)) : 7;
                nodemaxCount = thistypecountvalue > 21 ? Mathf.Ceil(Mathf.Sqrt(thistypecountvalue)) : 7;
                float rowcountn = Mathf.Ceil(thistypecountvalue1 / nodemaxCountype);
                float boxyval = rowcountn * rowwidth * columnysametype;     //换行
                Rect typeboxline = new Rect(-75, asj - 75, ((rowcountn > 1.0f || thistypecountvalue1 == nodemaxCountype) ? nodemaxCountype : (thistypecountvalue1 % nodemaxCountype)) * rowx, boxyval);
                allreverseboxrect[allreverseboxrectindex].TBR = typeboxline;
                allreverseboxrect[allreverseboxrectindex].TBRn = nowtypename1;
                if (GUInowtypename != string.Empty)
                {
                    allreverseboxrect[allreverseboxrectindex - 1].TBR1typeMaxCount = typeMaxCount;
                    accumulatetypeMaxCount += typeMaxCount;
                    typeMaxCount = 0;
                }
                allreverseboxrectindex++;
                asjfrontval = typeboxline.height + columny;
                asj += asjfrontval;
                GUInowtypename = nowtypename1;
            }
            /************************************/

            /*****************节点Rect**********************/
            float nodemaxwidth = nodemaxCount * rowx;
            float nodex = asetreversenodeasetindex * rowx % nodemaxwidth;      //节点的换行
            float asjfront = asj - asjfrontval;
            float nodey = asjfront + Mathf.Floor(asetreversenodeasetindex * rowx / nodemaxwidth) * rowwidth * columnysametype;
            elepos = ReversedependentList[i].ListRectPos = new Rect(nodex, nodey, rowwidth, columnheight);        //节点的Rect
            /************************************/

        }
        /********************************************************/
        allreverseboxrect[allreverseboxrectindex - 1].TBR1typeMaxCount = ReversedependentList.Count - accumulatetypeMaxCount;
    }
    private void ShownodeR()
    {
        float clampzoom = Mathf.Clamp(_zoom, 0.25f, 1);
        float clampzoom2 = Mathf.Clamp(_zoom, 0.75f, 1);
        float clampzoom3 = Mathf.Clamp(_zoom, 0.5f, 1);
        Event ec = Event.current;

        for (int i = 0; i < allreverseboxrect.Length; i++)
        {
            Rect allreverseboxrecti = allreverseboxrect[i].TBR;
            string allreverseboxrectin = allreverseboxrect[i].TBRn;
            int allreverseboxrectitmc = allreverseboxrect[i].TBR1typeMaxCount;
            allreverseboxrecti.x -= _zoomCoordsOrigin.x;
            allreverseboxrecti.y -= _zoomCoordsOrigin.y;
            if (EditorGUIUtility.isProSkin)
            {
                if (!iconisexist)
                {
                    GUI.color = new Color(0.4f, 0.4f, 0.4f, 0.9f);
                }
                else
                {
                    GUI.color = new Color(0.85f, 0.85f, 0.85f, 0.8f);
                }
            }
            else
            {
                if (!iconisexist)
                {
                    GUI.color = new Color(0.6f, 0.6f, 0.6f, 0.8f);
                }
                else
                {
                    GUI.color = new Color(0.85f, 0.85f, 0.85f, 0.8f);
                }
            }
            if (!iconisexist)
            {
                float tbbias = 15f;
                allreverseboxrecti = new Rect(allreverseboxrecti.x - tbbias, allreverseboxrecti.y - tbbias, allreverseboxrecti.width + tbbias * 2, allreverseboxrecti.height + tbbias * 2);
            }
            if (-allreverseboxrecti.x < allreverseboxrecti.width && -allreverseboxrecti.y < allreverseboxrecti.height)
            {
                if (allreverseboxrecti.x < (position.width - 8) / _zoom && allreverseboxrecti.y < (position.height - 62f) / _zoom)
                {
                    if (!iconisexist)
                    {
                        GUI.skin = GUISKINIcons;
                        GUI.Box(allreverseboxrecti, string.Empty);
                        GUI.skin = null;
                    }
                    else
                    {
                        if (!EditorGUIUtility.isProSkin)
                        {
                            GUI.Box(allreverseboxrecti, string.Empty, "window");
                        }
                        else
                        {
                            GUIStyle typeboxguis = new GUIStyle();
                            typeboxguis.normal.background = MakeTex(1, 1, new Color(0.4f, 0.4f, 0.4f, 0.9f));
                            GUI.Box(allreverseboxrecti, string.Empty, typeboxguis);
                        }
                    }
                }
            }
            GUI.color = Color.white;

            Rect labeltempboxrect = new Rect(allreverseboxrecti.x + 10, allreverseboxrecti.y - 160f, 1500f, 160f);
            if (-labeltempboxrect.x < labeltempboxrect.width && -labeltempboxrect.y < labeltempboxrect.height)
            {
                if (labeltempboxrect.x < (position.width - 8) / _zoom && labeltempboxrect.y < (position.height - 62f) / _zoom)
                {
                    GUIStyle fontsy = new GUIStyle();
                    fontsy.alignment = TextAnchor.LowerLeft;        //锚点放左下角
                    fontsy.fontSize = (int)(30 / clampzoom);
                    fontsy.fontStyle = FontStyle.Bold;

                    fontsy.normal.textColor = new Color(0.1f, 0.1f, 0.1f, 1f);      //搞个阴影
                    fontsy.contentOffset = Vector2.one * 3.5f / clampzoom;
                    GUI.Label(labeltempboxrect, allreverseboxrectin + " (" + allreverseboxrectitmc + ")", fontsy);

                    fontsy.contentOffset = Vector2.zero;
                    fontsy.normal.textColor = new Color(0.9f, 0.9f, 0.9f, 1f);
                    GUI.Label(labeltempboxrect, allreverseboxrectin + " (" + allreverseboxrectitmc + ")", fontsy);

                }
            }
        }

        /**********重置相关************/
        bool eleposisfirst = true;
        float zoomdivideheighthead = int.MaxValue;
        float zoomdividewidthhead = int.MaxValue;
        float zoomdivideheighthead2 = int.MinValue;
        float zoomdividewidthhead2 = int.MinValue;
        Vector2 elepos0temp = Vector2.zero;
        Vector2 eleposnowtemp = Vector2.zero;
        /*******************************/

        foreach (string i in ReversedependentList.Keys)
        {
            ASETRevesenode asetreversenode = ReversedependentList[i];
            int stringspaceindex = i.LastIndexOf(stringspace);
            string nowtypename1 = i.Substring(stringspaceindex + 1);    //type
            string nowpathname2 = i.Substring(0, stringspaceindex);     //path


            float nodeexpend = 20f;     //缩放Rect
            Rect shadowasetreverserect = asetreversenode.ListRectPos;
            shadowasetreverserect.x -= _zoomCoordsOrigin.x;
            shadowasetreverserect.y -= _zoomCoordsOrigin.y;
            shadowasetreverserect.x += 5;
            shadowasetreverserect.y += 5;
            shadowasetreverserect = new Rect(shadowasetreverserect.x - nodeexpend, shadowasetreverserect.y - nodeexpend, shadowasetreverserect.width + nodeexpend * 2, shadowasetreverserect.height + nodeexpend * 2);
            if (shadowasetreverserect.Contains(ec.mousePosition) && ec.button == 0)
            {
                if (ec.type == EventType.MouseDown)
                {
                    asetreversenode.Isreversepress = false;
                }
                else if (ec.type == EventType.MouseUp)
                {
                    asetreversenode.Isreversepress = true;
                }
            }
            if (asetreversenode.Isreversepress)
            {
                if (-shadowasetreverserect.x < shadowasetreverserect.width && -shadowasetreverserect.y < shadowasetreverserect.height)      //阴影
                {
                    if (shadowasetreverserect.x < (position.width - 8) / _zoom && shadowasetreverserect.y < (position.height - 62f) / _zoom)
                    {
                        GUI.color = Color.black;
                        GUI.Box(shadowasetreverserect, string.Empty);
                        GUI.color = Color.white;
                    }
                }
                GUI.changed = true;
            }


            Rect asetreverserect = asetreversenode.ListRectPos;
            asetreverserect.x -= _zoomCoordsOrigin.x;
            asetreverserect.y -= _zoomCoordsOrigin.y;

            /**********重置需要************/
            if (eleposisfirst)  //记录第一个节点的位置
            {
                elepos0temp = new Vector2(asetreverserect.x, asetreverserect.y);
                eleposisfirst = false;
            }
            eleposnowtemp = new Vector2(asetreverserect.x, asetreverserect.y);
            zoomdivideheighthead = Mathf.Min(zoomdivideheighthead, asetreverserect.y);   //算出最大最小长度宽度
            zoomdivideheighthead2 = Mathf.Max(zoomdivideheighthead2, asetreverserect.y);
            zoomdividewidthhead = Mathf.Min(zoomdividewidthhead, asetreverserect.x);
            zoomdividewidthhead2 = Mathf.Max(zoomdividewidthhead2, asetreverserect.x);
            /*******************************/

            float pathtimer = 0.6667f;
            asetreverserect.height *= pathtimer;
            asetreverserect = new Rect(asetreverserect.x - nodeexpend, asetreverserect.y - nodeexpend, asetreverserect.width + nodeexpend * 2, asetreverserect.height + nodeexpend * 2);
            Type sffict = IconShowType(nowpathname2);

            /*********************定位*******************************/
            if (asetreverserect.Contains(ec.mousePosition) && ec.type == EventType.MouseDown && ec.button == 0 && ec.clickCount == 2)
            {
                if (sffict != null)
                {
                    UnityEngine.Object obj = AssetDatabase.LoadAssetAtPath(nowpathname2, sffict);
                    EditorGUIUtility.PingObject(obj);   //定位
                    Selection.activeObject = obj;   //点击
                }
                else
                {
                    ShowNotification(new GUIContent("Cannot locate the file, please install related package or search for file manually"), 3.0f);
                }
                // Event.current.Use(); //同Repaint()以及GUI.changed = true;但是这个use可能会导致像toggle类的无法触发
                GUI.changed = true;
                // Repaint();
            }
            /****************************************************/


            /**********************图标显示***************************/
            if (-asetreverserect.x < asetreverserect.width && -asetreverserect.y < asetreverserect.height)
            {
                if (asetreverserect.x < (position.width - 8) / _zoom && asetreverserect.y < (position.height - 62f) / _zoom)
                {
                    // if (!iconisexist)
                    // {
                    //     GUI.skin = GUISKINIcons;
                    //     GUI.Box(asetreverserect, string.Empty);
                    //     GUI.skin = null;
                    // }
                    // else
                    // {
                    GUI.Box(asetreverserect, string.Empty, "GroupBox");
                    // }

                    if (sffict != null && sffict.Name == "Texture2D")//图片类
                    {
                        Texture2D texture = AssetDatabase.LoadAssetAtPath<Texture2D>(nowpathname2);
                        if (texture.width <= texture.height)
                        {
                            //     aseIconrect.x += -50.434f * (texture.width / texture.height) + 74.256f;
                            asetreverserect.x += 40;
                        }

                        GUI.Label(asetreverserect, texture);
                    }
                    else    //图标类
                    {
                        Rect newasetreverserect = asetreverserect;
                        newasetreverserect.width = newasetreverserect.height = Mathf.Min(newasetreverserect.width, newasetreverserect.height);
                        if (nowtypename1 == ASWFolderNames[0])
                        {
                            newasetreverserect.x += 25;
                        }
                        else
                        {
                            newasetreverserect.x += 65;
                        }
                        GUI.Label(newasetreverserect, IconShow(nowpathname2));
                    }
                }
            }
            /****************************************************/

            /*************************路径显示***********************/
            Rect pathasetreverse = asetreverserect;
            pathasetreverse.y += asetreverserect.height;
            pathasetreverse.height = asetreversenode.ListRectPos.height * (1 - pathtimer);
            if (-pathasetreverse.x < pathasetreverse.width && -pathasetreverse.y < pathasetreverse.height)
            {
                if (pathasetreverse.x < (position.width - 8) / _zoom && pathasetreverse.y < (position.height - 62f) / _zoom)
                {
                    GUI.color = Color.white * (EditorGUIUtility.isProSkin ? 1 : 0.85f);
                    GUIStyle TextGUIs = new GUIStyle("ScriptText");
                    TextGUIs.fontSize = (int)(12 / clampzoom2);
                    TextGUIs.wordWrap = true;
                    GUI.TextField(pathasetreverse, nowpathname2, TextGUIs);

                    GUIStyle TransparentTextField = new GUIStyle();
                    TransparentTextField.normal.textColor = Color.clear;
                    GUI.Label(pathasetreverse, new GUIContent(string.Empty, nowpathname2), TransparentTextField);
                    GUI.Label(pathasetreverse, GUI.tooltip, TransparentTextField);
                    GUI.color = Color.white;
                }
            }
            /****************************************************/
        }

        /**********重置相关************/
        float eleposnowtemptime0 = 1f;
        float eleposnowtemptime1 = 3f;
        if ((Event.current.type == EventType.MouseUp || Event.current.type == EventType.MouseDown) && Event.current.button == 2)
        {
            zoomstartvaluetime = eleposnowtemptime0;
            GUI.changed = true;
        }
        if (zoomstartvaluetime >= eleposnowtemptime0 && zoomstartvaluetime < eleposnowtemptime1)
        {
            zoomstartvaluetime += Time.deltaTime;
            GUI.changed = true;
        }
        else
        {
            zoomstartvaluetime = 0.0f;
            GUI.changed = true;
        }
        float eleposnowtemptimehalf01 = (eleposnowtemptime1 - eleposnowtemptime0) / 2f;
        if (zoomstartvaluetime > eleposnowtemptimehalf01)
        {
            float realheight = position.height - (25.5f + 62f);
            float realwidth = position.width - (4 + 8);
            float zoomdivideheadrow2 = Mathf.Abs(zoomdividewidthhead2 - zoomdividewidthhead) + rowwidth + 300;
            float zoomdivideheadrow = zoomdivideheadrow2;
            float zoomdivideheadcolumn2 = Mathf.Abs(zoomdivideheighthead2 - zoomdivideheighthead) + columnheight + 300;
            float zoomdivideheadcolumn = zoomdivideheadcolumn2;
            _zoom = Mathf.Min(1f, realheight / zoomdivideheadcolumn, realwidth / zoomdivideheadrow);
            if (ReversedependentList.Count > 1)
            {
                float zoomx = zoomdividewidthhead - elepos0temp.x - (realwidth / 2 / _zoom - zoomdivideheadrow2 / 2) - 137f;
                float zoomy = zoomdivideheighthead - elepos0temp.y - (realheight / 2 / _zoom - zoomdivideheadcolumn2 / 2) - (17.185f / _zoom + 178.78f);
                _zoomCoordsOrigin = new Vector2(zoomx, zoomy);
            }
            else
            {
                _zoomCoordsOrigin = new Vector2(-(position.width - (4 + 8) - rowwidth) / 2, -(position.height - (25.5f + 62f) - columnheight) / 2);
                _zoomCoordsOrigin += eleposnowtemp;
            }
            GUI.changed = true;
        }
    }



    private void Shownode(ref int allselectedcount, ref int allselectednowcount, ref int alldependcount, ref int alldependnowcount, ref int allhidnowcount, ref bool iscancelcurrent, ref List<Vector2> typenamelist, Rect zoomexpandbuttonrect)
    {

        Event ec = Event.current;

        /**********种类边框初始化************/
        float asj = 0;
        int intypecountindex = 0;
        string GUInowtypename = string.Empty;
        int singletypecount = intypecount[intypecountindex];
        float nodemaxCount = singletypecount > 21 ? Mathf.Ceil(Mathf.Sqrt(singletypecount)) : 7;    //每nodemaxCount换行
        float clampzoom = Mathf.Clamp(_zoom, 0.25f, 1);
        float clampzoom2 = Mathf.Clamp(_zoom, 0.75f, 1);
        float clampzoom3 = Mathf.Clamp(_zoom, 0.5f, 1);
        float rowcountn = Mathf.Ceil(singletypecount / nodemaxCount);
        float boxyval = rowcountn * rowwidth * columnysametype;     //换行
        // Rect typeboxline = new Rect(-75 - _zoomCoordsOrigin.x, asj - 100 - _zoomCoordsOrigin.y + (35 - 1 / clampzoom * 35), ((rowcountn > 1.0f || singletypecount == nodemaxCount) ? nodemaxCount : (singletypecount % nodemaxCount)) * rowx + 50, boxyval + (1 / clampzoom * 35 - 35));
        Rect typeboxline = new Rect(-75f - _zoomCoordsOrigin.x, asj - 75f - _zoomCoordsOrigin.y, ((rowcountn > 1.0f || singletypecount == nodemaxCount) ? nodemaxCount : (singletypecount % nodemaxCount)) * rowx, boxyval);
        if (!iconisexist)
        {
            float tbbias = 15f;
            typeboxline = new Rect(typeboxline.x - tbbias, typeboxline.y - tbbias, typeboxline.width + tbbias * 2, typeboxline.height + tbbias * 2);
        }

        asj -= typeboxline.height + columny;
        /*******************************/

        /**********重置相关************/
        bool eleposisfirst = true;
        float zoomdivideheighthead = int.MaxValue;
        float zoomdividewidthhead = int.MaxValue;
        float zoomdivideheighthead2 = int.MinValue;
        float zoomdividewidthhead2 = int.MinValue;
        Vector2 elepos0temp = Vector2.zero;
        Vector2 eleposnowtemp = Vector2.zero;
        /*******************************/

        /**********检测三个种类是否选全*******/
        bool allnoneselectdependIS0temp = true;
        bool allnoneselectdependIS2temp = true;
        bool allnoneselectdependIS4temp = true;
        bool allnoneselectdependIS6temp = true;
        /***********************************/

        /**********ec.clickCount==2无法控制时长，自己写了一个控制时长的双击**************/
        if (clickcount > 0)
        {
            clickcountime += Time.deltaTime;
        }
        if (clickcountime > 1f)
        {
            clickcountime = 0.0f;
            clickcount = 0;
        }
        /****************************************************************************/

        foreach (string i in aSETnodes.Keys)
        {
            ASETnode asetnodeval = aSETnodes[i];
            int stringspaceindex = i.LastIndexOf(stringspace);
            string nowtypename1 = i.Substring(stringspaceindex + 1);    //type
            string nowpathname1 = i.Substring(0, stringspaceindex);     //path

            bool issamenowtypename = GUInowtypename != nowtypename1;

            /**************种类边框***************/
            if (issamenowtypename)
            {
                singletypecount = intypecount[intypecountindex];
                nodemaxCount = singletypecount > 21 ? Mathf.Ceil(Mathf.Sqrt(singletypecount)) : 7;      //单种类换行
                asj += typeboxline.height + columny;
                intypecountindex++;
                GUInowtypename = nowtypename1;
                if (EditorGUIUtility.isProSkin)
                {
                    if (!iconisexist)
                    {
                        GUI.color = new Color(0.4f, 0.4f, 0.4f, 0.9f);
                    }
                    else
                    {
                        GUI.color = new Color(0.85f, 0.85f, 0.85f, 0.8f);
                    }
                }
                else
                {
                    if (!iconisexist)
                    {
                        GUI.color = new Color(0.6f, 0.6f, 0.6f, 0.8f);
                    }
                    else
                    {
                        GUI.color = new Color(0.85f, 0.85f, 0.85f, 0.8f);
                    }
                }
                rowcountn = Mathf.Ceil(singletypecount / nodemaxCount);
                boxyval = rowcountn * rowwidth * columnysametype;     //换行
                // typeboxline = new Rect(-75 - _zoomCoordsOrigin.x, asj - 100 - _zoomCoordsOrigin.y + (35 - 1 / clampzoom * 35), ((rowcountn > 1.0f || singletypecount == nodemaxCount) ? nodemaxCount : (singletypecount % nodemaxCount)) * rowx + 50, boxyval + (1 / clampzoom * 35 - 35));
                typeboxline = new Rect(-75f - _zoomCoordsOrigin.x, asj - 75f - _zoomCoordsOrigin.y, ((rowcountn > 1.0f || singletypecount == nodemaxCount) ? nodemaxCount : (singletypecount % nodemaxCount)) * rowx, boxyval);
                if (!iconisexist)
                {
                    float tbbias = 15f;
                    typeboxline = new Rect(typeboxline.x - tbbias, typeboxline.y - tbbias, typeboxline.width + tbbias * 2, typeboxline.height + tbbias * 2);
                }

                typenamelist.Add(new Vector2(typeboxline.x, typeboxline.y));//连线函数中种类名称需要

                // GUI.Box(typeboxline, string.Empty, "window");
                if (-typeboxline.x < typeboxline.width && -typeboxline.y < typeboxline.height)
                {
                    if (typeboxline.x < (position.width - 8) / _zoom && typeboxline.y < (position.height - 62f) / _zoom)
                    {
                        if (!iconisexist)
                        {
                            GUI.skin = GUISKINIcons;
                            GUI.Box(typeboxline, string.Empty);
                            GUI.skin = null;
                        }
                        else
                        {
                            if (!EditorGUIUtility.isProSkin)
                            {
                                GUI.Box(typeboxline, string.Empty, "window");
                            }
                            else
                            {
                                GUIStyle typeboxguis = new GUIStyle();
                                typeboxguis.normal.background = MakeTex(1, 1, new Color(0.4f, 0.4f, 0.4f, 0.9f));
                                GUI.Box(typeboxline, string.Empty, typeboxguis);
                            }
                        }
                    }
                }
                GUI.color = Color.white;
            }

            if (!File.Exists(nowpathname1))      //如果用户移动了文件位置
            {
                /***************原本设计是搜索直到找到文件重新定位********************/
                // string nowpathnamesname = Path.GetFileName(nowpathname1);
                // string[] allFilesInDir = AssetDatabase.GetAllAssetPaths();
                // for (int q = 0; q < allFilesInDir.Length; q++)
                // {
                //     string singlefilepath = allFilesInDir[q];
                //     if (singlefilepath.StartsWith(ASWFolderNames[21] + stringslash) && File.Exists(singlefilepath))
                //     {
                //         string singlefilepathname = Path.GetFileName(singlefilepath);
                //         if (singlefilepathname == nowpathnamesname && ListClassified2(singlefilepath) == nowtypename1)
                //         {
                //             Dictionary<string, ASETnode> asetnodetemp = new Dictionary<string, ASETnode>();
                //             foreach (string z in aSETnodes.Keys)
                //             {
                //                 ASETnode aseti = aSETnodes[z];
                //                 if (z == i)
                //                 {
                //                     string newi = singlefilepath + stringspace + nowtypename1;
                //                     nowpathname1 = singlefilepath;
                //                     asetnodetemp.Add(newi, aseti);
                //                 }
                //                 else
                //                 {
                //                     asetnodetemp.Add(z, aseti);
                //                 }
                //             }
                //             aSETnodes = asetnodetemp;
                //             break;
                //         }
                //     }
                // }
                // ShowNotification(new GUIContent("Move files behavior detected"), 2.0f);
                // continue;
                /************************************/

                EditorUtility.DisplayDialog("Notification", "Move files behavior detected!", "OK");
                wnd.Close();
                return;
            }

            bool ISListHeadnpn = ListHeadClickSeleted.Contains(nowpathname1);
            /***********************************/

            /**********多选冲突相关************/
            string aswfnqiaseti = nowtypename1 + asetnodeval.asetindex;
            if (currentSelectedIndex.Contains(aswfnqiaseti))
            {
                aSETnodes[i].ListMouseClickIsSelected = true;
                if (!ISListHeadnpn)
                {
                    ListHeadClickSeleted.Add(nowpathname1);
                }
            }
            else
            {
                if (!selectedtypetemp.Contains(i))
                {
                    aSETnodes[i].ListMouseClickIsSelected = false;
                }
                else
                {
                    selectedtypetemp.Remove(i);
                }
                if (ISListHeadnpn)
                {
                    ListHeadClickSeleted.Remove(nowpathname1);
                }
            }
            /********************************/



            /**********非高亮（默认）节点Rect计算************/
            float nodemaxwidth = nodemaxCount * rowx;
            float nodex = asetnodeval.asetindex * rowx % nodemaxwidth;      //节点的换行
            float nodey = asj + Mathf.Floor(asetnodeval.asetindex * rowx / nodemaxwidth) * rowwidth * columnysametype;
            Rect elepos = aSETnodes[i].ListRectPos = new Rect(nodex - _zoomCoordsOrigin.x, nodey - _zoomCoordsOrigin.y, rowwidth, columnheight);        //节点的Rect

            /*******************************/

            /**********节点（高亮头文件，高亮依赖文件或是非高亮）的Rect计算************/
            float magitimer = (ISListHeadnpn ? 1.3f : 1.0f) / clampzoom2;
            float magitimerfunc = elepos.width / 2 * magitimer - elepos.width / 2;
            Rect whiteBG = new Rect(elepos.x - magitimerfunc, elepos.y - magitimerfunc, elepos.width * magitimer, elepos.height * magitimer);
            float outerselectedfontsize = 20 / clampzoom2;
            Rect outputListIsSelectedrect = aSETnodes[i].ListMouseClickIsSelected ? new Rect(whiteBG.x, whiteBG.y, outerselectedfontsize, outerselectedfontsize) : new Rect(elepos.x, elepos.y, outerselectedfontsize, outerselectedfontsize);
            /*******************************/

            /**********重置需要************/
            if (eleposisfirst)  //记录第一个节点的位置
            {
                elepos0temp = new Vector2(asetnodeval.ListRectPos.x, asetnodeval.ListRectPos.y);
                eleposisfirst = false;
            }
            zoomdivideheighthead = Mathf.Min(zoomdivideheighthead, elepos.y);   //算出最大最小长度宽度
            zoomdivideheighthead2 = Mathf.Max(zoomdivideheighthead2, elepos.y);
            zoomdividewidthhead = Mathf.Min(zoomdividewidthhead, elepos.x);
            zoomdividewidthhead2 = Mathf.Max(zoomdividewidthhead2, elepos.x);
            /*******************************/

            /**********选中蓝色，依赖红色，无用紫色************/
            bool jisisselected = asetnodeval.ListIsSelected;
            if (jisisselected)
            {
                allselectedcount++;
                if (aSETnodes[i].outputListIsSelected)
                {
                    allselectednowcount++;
                }
                if (allnoneselectdependIS[3])
                {
                    aSETnodes[i].outputListIsSelected = allnoneselectdependIS[2];
                }
                allnoneselectdependIS2temp &= aSETnodes[i].outputListIsSelected;

                if (EditorGUIUtility.isProSkin)
                {
                    if (!iconisexist)
                    {
                        GUI.color = new Color(0, 0, 1, asetnodeval.ListMouseClickIsSelected ? (ISListHeadnpn ? 0.9f : 0.4f) : 0.2f);
                    }
                }
                else
                {

                    if (!iconisexist)
                    {
                        GUI.color = new Color(0, 0, 1, asetnodeval.ListMouseClickIsSelected ? (ISListHeadnpn ? 0.9f : 0.35f) : 0.1f);
                    }
                    else
                    {
                        GUI.color = new Color(0, 0, 1, asetnodeval.ListMouseClickIsSelected ? (ISListHeadnpn ? 0.9f : 0.35f) : 0.5f);
                    }
                }
                float guiboxtimer = ISListHeadnpn ? 1.65f : 1.3f;
                if (asetnodeval.ListMouseClickIsSelected)
                {
                    guiboxtimer /= clampzoom2;
                    guiboxtimer *= 1.1f;
                }
                if (!iconisexist)
                {
                    if (ISListHeadnpn)
                    {
                        guiboxtimer *= 1.075f;
                    }
                    else if (asetnodeval.ListMouseClickIsSelected)
                    {
                        guiboxtimer *= 1.05f;
                    }
                    else
                    {
                        guiboxtimer *= 1.075f;
                    }
                }
                float guiboxtimerbias = 0.5f * guiboxtimer - 0.5f;
                // GUI.Box(new Rect(elepos.x - rowwidth * guiboxtimerbias, elepos.y - columnheight * guiboxtimerbias, elepos.width * guiboxtimer, elepos.height * guiboxtimer), string.Empty, asetnodeval.ListMouseClickIsSelected ? "GroupBox" : "HelpBox");
                Rect boxtemprect = new Rect(elepos.x - rowwidth * guiboxtimerbias, elepos.y - columnheight * guiboxtimerbias, elepos.width * guiboxtimer, elepos.height * guiboxtimer);      //非高亮选中节点下框
                if (-boxtemprect.x < boxtemprect.width && -boxtemprect.y < boxtemprect.height)
                {
                    if (boxtemprect.x < (position.width - 8) / _zoom && boxtemprect.y < (position.height - 62f) / _zoom)
                    {
                        if (!iconisexist)
                        {
                            GUI.skin = GUISKINIcons;
                            GUI.Box(boxtemprect, string.Empty);
                            GUI.skin = null;
                        }
                        else
                        {
                            if (!EditorGUIUtility.isProSkin)
                            {
                                GUI.Box(boxtemprect, string.Empty, asetnodeval.ListMouseClickIsSelected ? "GroupBox" : "HelpBox");
                            }
                            else
                            {
                                GUIStyle SeletedBGrectblue = new GUIStyle();
                                SeletedBGrectblue.normal.background = MakeTex(1, 1, new Color(0, 0, 1, asetnodeval.ListMouseClickIsSelected ? (ISListHeadnpn ? 1 : 0.6f) : 0.2f));
                                GUI.Box(boxtemprect, string.Empty, SeletedBGrectblue);
                            }
                        }
                    }
                }
                GUI.color = Color.white;
            }
            else
            {
                if (!UselessMatexModel.Contains(i))
                {
                    alldependcount++;
                    if (aSETnodes[i].outputListIsSelected)
                    {
                        alldependnowcount++;
                    }
                    if (allnoneselectdependIS[5])
                    {
                        aSETnodes[i].outputListIsSelected = allnoneselectdependIS[4];
                    }
                    allnoneselectdependIS4temp &= aSETnodes[i].outputListIsSelected;
                }

                if (EditorGUIUtility.isProSkin)
                {
                    if (!iconisexist)
                    {
                        if (UselessMatexModel.Contains(i))
                        {
                            GUI.color = new Color(1, 0, 1, asetnodeval.ListMouseClickIsSelected ? (ISListHeadnpn ? 0.9f : 0.4f) : 0.2f);    //紫色
                        }
                        else
                        {
                            GUI.color = new Color(1, 0, 0, asetnodeval.ListMouseClickIsSelected ? (ISListHeadnpn ? 0.9f : 0.4f) : 0.2f);       //红色
                        }
                    }
                }
                else
                {
                    if (!iconisexist)
                    {
                        if (UselessMatexModel.Contains(i))
                        {
                            GUI.color = new Color(1, 0, 1, asetnodeval.ListMouseClickIsSelected ? (ISListHeadnpn ? 0.9f : 0.35f) : 0.1f);    //紫色
                        }
                        else
                        {
                            GUI.color = new Color(1, 0, 0, asetnodeval.ListMouseClickIsSelected ? (ISListHeadnpn ? 0.9f : 0.35f) : 0.1f);       //红色
                        }
                    }
                    else
                    {
                        if (UselessMatexModel.Contains(i))
                        {
                            GUI.color = new Color(1, 0, 1, asetnodeval.ListMouseClickIsSelected ? (ISListHeadnpn ? 0.8f : 0.25f) : 0.4f);       //紫色
                        }
                        else
                        {
                            GUI.color = new Color(1, 0, 0, asetnodeval.ListMouseClickIsSelected ? (ISListHeadnpn ? 0.9f : 0.35f) : 0.5f);       //红色
                        }
                    }
                }
                float guiboxtimer = ISListHeadnpn ? 1.65f : 1.3f;
                if (asetnodeval.ListMouseClickIsSelected)
                {
                    guiboxtimer /= clampzoom2;
                    guiboxtimer *= 1.1f;
                }
                if (!iconisexist)
                {
                    if (ISListHeadnpn)
                    {
                        guiboxtimer *= 1.075f;
                    }
                    else if (asetnodeval.ListMouseClickIsSelected)
                    {
                        guiboxtimer *= 1.05f;
                    }
                    else
                    {
                        guiboxtimer *= 1.075f;
                    }
                }
                float guiboxtimerbias = 0.5f * guiboxtimer - 0.5f;
                // GUI.Box(new Rect(elepos.x - rowwidth * guiboxtimerbias, elepos.y - columnheight * guiboxtimerbias, rowwidth * guiboxtimer, columnheight * guiboxtimer), string.Empty, asetnodeval.ListMouseClickIsSelected ? "GroupBox" : "HelpBox");
                Rect boxtemprect = new Rect(elepos.x - rowwidth * guiboxtimerbias, elepos.y - columnheight * guiboxtimerbias, rowwidth * guiboxtimer, columnheight * guiboxtimer);      //非高亮依赖节点下框
                if (-boxtemprect.x < boxtemprect.width && -boxtemprect.y < boxtemprect.height)
                {
                    if (boxtemprect.x < (position.width - 8) / _zoom && boxtemprect.y < (position.height - 62f) / _zoom)
                    {
                        if (!EditorGUIUtility.isProSkin)
                        {
                            if (!iconisexist)
                            {
                                GUI.skin = GUISKINIcons;
                                GUI.Box(boxtemprect, string.Empty);
                                GUI.skin = null;
                            }
                            else
                            {
                                GUI.Box(boxtemprect, string.Empty, asetnodeval.ListMouseClickIsSelected ? "GroupBox" : "HelpBox");
                            }
                        }
                        else
                        {
                            if (!iconisexist)
                            {
                                GUI.skin = GUISKINIcons;
                                GUI.Box(boxtemprect, string.Empty);
                                GUI.skin = null;
                            }
                            else
                            {
                                GUIStyle SeletedBGrectblue = new GUIStyle();
                                if (UselessMatexModel.Contains(i))
                                {
                                    SeletedBGrectblue.normal.background = MakeTex(1, 1, new Color(1, 0, 1, asetnodeval.ListMouseClickIsSelected ? (ISListHeadnpn ? 0.5f : 0.3f) : 0.1f));
                                }
                                else
                                {
                                    SeletedBGrectblue.normal.background = MakeTex(1, 1, new Color(1, 0, 0, asetnodeval.ListMouseClickIsSelected ? (ISListHeadnpn ? 0.9f : 0.4f) : 0.2f));
                                }
                                GUI.Box(boxtemprect, string.Empty, SeletedBGrectblue);
                            }
                        }
                    }
                }
                GUI.color = Color.white;
            }
            /****************************************/

            /**********高亮相关************/
            Type sffict = IconShowType(nowpathname1);
            if (aSETnodes[i].ListMouseClickIsSelected)
            {
                eleposnowtemp = new Vector2(elepos.x, elepos.y);
                if (ISListHeadnpn)      //高亮且是主节点显示
                {
                    /**********白色底************/
                    GUIStyle ColorGUIstyle = new GUIStyle();
                    ColorGUIstyle.normal.background = MakeTex(1, 1, new Color(0.9f, 0.9f, 0.9f, 1.0f));
                    aSETnodes[i].ListRectPos = whiteBG;
                    // GUI.Box(whiteBG, string.Empty, ColorGUIstyle);
                    if (-whiteBG.x < whiteBG.width && -whiteBG.y < whiteBG.height)
                    {
                        if (whiteBG.x < (position.width - 8) / _zoom && whiteBG.y < (position.height - 62f) / _zoom)
                        {
                            GUI.Box(whiteBG, string.Empty, ColorGUIstyle);
                        }
                    }
                    /*******************************/

                    /**********路径显示************/
                    float texttimer = 3 / clampzoom2;
                    Rect pathstringrect = elepos;
                    pathstringrect.y += columnheight / texttimer * (texttimer - 1) + 40 * clampzoom2 - 40;
                    pathstringrect.height /= texttimer;
                    pathstringrect.height += -40 * clampzoom2 + 40;
                    float magitimerminusone = magitimer - 1;
                    pathstringrect.x -= elepos.width * magitimerminusone / 2;
                    pathstringrect.width += elepos.width * magitimerminusone;
                    pathstringrect.y += 25 * magitimerminusone;
                    pathstringrect.height *= magitimer;
                    PathGUIshow(elepos, elepos0temp, whiteBG, nowpathname1, i, pathstringrect, 20, clampzoom2);
                    /*******************************/


                    /**********图标图片相关************/
                    // float halfrowwidth = rowwidth / 2;
                    // float TexTimer = 0.6f * magitimer;
                    // Rect aseIconrect = new Rect(elepos.x + elepos.width / 2 - halfrowwidth * TexTimer, elepos.y + 5, elepos.width * TexTimer, elepos.height * TexTimer);
                    // aseIconrect.y -= elepos.width / 2 * magitimerminusone;
                    Rect aseIconrect = new Rect(whiteBG.x, whiteBG.y, whiteBG.width, whiteBG.height - pathstringrect.height);
                    if (sffict != null && sffict.Name == "Texture2D")//图标
                    {
                        if (-aseIconrect.x < aseIconrect.width && -aseIconrect.y < aseIconrect.height)
                        {
                            if (aseIconrect.x < (position.width - 8) / _zoom && aseIconrect.y < (position.height - 62f) / _zoom)
                            {
                                Texture2D texture = AssetDatabase.LoadAssetAtPath<Texture2D>(nowpathname1);
                                if (texture.width <= texture.height)
                                {
                                    //     aseIconrect.x += -64.538f * (texture.width / texture.height) + 95;
                                    aseIconrect.x += 40;
                                }
                                GUI.Label(aseIconrect, texture);
                            }
                        }
                    }
                    else
                    {
                        // aseIconrect.x += halfrowwidth * TexTimer - (halfrowwidth - 10) / 2 + (nowtypename1 == ASWFolderNames[0] ? (ISListHeadnpn ? -5 : -11) : 0);
                        // aseIconrect.x -= -63f * clampzoom2 + 80;
                        aseIconrect.width = aseIconrect.height = Mathf.Min(aseIconrect.width, aseIconrect.height);
                        aseIconrect.x += 45;
                        if (-aseIconrect.x < aseIconrect.width && -aseIconrect.y < aseIconrect.height)
                        {
                            if (aseIconrect.x < (position.width - 8) / _zoom && aseIconrect.y < (position.height - 62f) / _zoom)
                            {
                                GUI.DrawTexture(aseIconrect, IconShow(nowpathname1).image);
                            }
                        }
                    }
                    /*******************************/
                }
                else    //高亮依赖节点显示
                {
                    /**********白色底************/
                    float elepostxybias = -100 / magitimer + 100;
                    Rect elepost = new Rect(elepos.x - elepostxybias, elepos.y - elepostxybias, elepos.width * magitimer, elepos.height * magitimer);
                    aSETnodes[i].ListRectPos = elepost;
                    if (-elepost.x < elepost.width && -elepost.y < elepost.height)
                    {
                        if (elepost.x < (position.width - 8) / _zoom && elepost.y < (position.height - 62f) / _zoom)
                        {
                            GUIStyle ColorGUIstyle = new GUIStyle();
                            ColorGUIstyle.normal.background = MakeTex(1, 1, new Color(0.9f, 0.9f, 0.9f, 1.0f));
                            GUI.Box(elepost, string.Empty, ColorGUIstyle);
                        }
                    }
                    /*******************************/

                    /**********路径显示************/
                    Rect pathstringrect = elepost;
                    pathstringrect.y += magitimer * 116.667f - 30f;
                    pathstringrect.height -= magitimer * 116.667f - 30f;
                    PathGUIshow(elepos, elepos0temp, elepost, nowpathname1, i, pathstringrect, 12, clampzoom2);
                    /*******************************/

                    /**********图标图片相关************/
                    // float halfrowwidth = rowwidth / 2;
                    // float TexTimer = (-0.4f * clampzoom2 + 0.9f) / clampzoom2;
                    // Rect aseIconrect = new Rect(elepos.x + elepos.width / 2 - halfrowwidth * TexTimer, elepos.y + 5, elepos.width * TexTimer, elepos.height * TexTimer);
                    Rect aseIconrect = new Rect(elepost.x, elepost.y, elepost.width, (elepost.height - pathstringrect.height));
                    if (sffict != null && sffict.Name == "Texture2D")   //图片类
                    {
                        if (-aseIconrect.x < aseIconrect.width && -aseIconrect.y < aseIconrect.height)
                        {
                            if (aseIconrect.x < (position.width - 8) / _zoom && aseIconrect.y < (position.height - 62f) / _zoom)
                            {
                                Texture2D texture = AssetDatabase.LoadAssetAtPath<Texture2D>(nowpathname1);
                                if (texture.width <= texture.height)
                                {
                                    //     aseIconrect.x += -62.707f * (texture.width / texture.height) + 97.636f;
                                    aseIconrect.x += 40;
                                }
                                GUI.Label(aseIconrect, texture);
                            }
                        }
                    }
                    else//图标
                    {
                        // aseIconrect.x += halfrowwidth * TexTimer - (halfrowwidth - 10) / 2 + (nowtypename1 == ASWFolderNames[0] ? (ISListHeadnpn ? -5 : -1) : 0);
                        // aseIconrect.y += 100 * clampzoom2 - 100;
                        aseIconrect.width = aseIconrect.height = Mathf.Min(aseIconrect.width, aseIconrect.height);
                        aseIconrect.x += 65;
                        if (-aseIconrect.x < aseIconrect.width && -aseIconrect.y < aseIconrect.height)
                        {
                            if (aseIconrect.x < (position.width - 8) / _zoom && aseIconrect.y < (position.height - 62f) / _zoom)
                            {
                                GUI.Label(aseIconrect, IconShow(nowpathname1).image);
                            }
                        }
                    }
                    /*******************************/
                }
            }
            else    //非高亮节点显示
            {
                // float halfrowwidth = rowwidth / 2;
                // float TexTimer = 0.6f;
                // Rect aseIconrect = new Rect(elepos.x + elepos.width / 2 - halfrowwidth * TexTimer, elepos.y + 5, elepos.width * TexTimer, elepos.height * TexTimer);

                float texttimer = 3;
                GUI.color = Color.white * 0.2f;     //非高亮情况下需要压暗颜色
                {
                    /**********白色底************/
                    if (-elepos.x < elepos.width && -elepos.y < elepos.height)
                    {
                        if (elepos.x < (position.width - 8) / _zoom && elepos.y < (position.height - 62f) / _zoom)
                        {
                            GUI.Box(elepos, string.Empty, "GroupBox");
                        }
                    }
                    /*******************************/

                    /**********图标图片相关************/

                    Rect pathstringrect = new Rect(elepos.x, elepos.y + columnheight / texttimer * (texttimer - 1), rowwidth, columnheight / texttimer);
                    Rect aseIconrect = new Rect(elepos.x, elepos.y, elepos.width, elepos.height - pathstringrect.height);
                    if (-aseIconrect.x < aseIconrect.width && -aseIconrect.y < aseIconrect.height)
                    {
                        if (aseIconrect.x < (position.width - 8) / _zoom && aseIconrect.y < (position.height - 62f) / _zoom)
                        {
                            if (sffict != null && sffict.Name == "Texture2D")//图片类
                            {
                                Texture2D texture = AssetDatabase.LoadAssetAtPath<Texture2D>(nowpathname1);
                                if (texture.width <= texture.height)
                                {
                                    //     aseIconrect.x += -50.434f * (texture.width / texture.height) + 74.256f;
                                    aseIconrect.x += 40;
                                }

                                GUI.Label(aseIconrect, texture);
                            }
                            else    //图标类
                            {
                                aseIconrect.width = aseIconrect.height = Mathf.Min(aseIconrect.width, aseIconrect.height);
                                if (nowtypename1 == ASWFolderNames[0])
                                {
                                    aseIconrect.x += 25;
                                }
                                else
                                {
                                    aseIconrect.x += 45;
                                }
                                // Rect aseIconrectbias = new Rect(aseIconrect.x + halfrowwidth * TexTimer - (halfrowwidth - 10) / 2 + (nowtypename1 == ASWFolderNames[0] ? (ISListHeadnpn ? -5 : -11) : 0), aseIconrect.y, aseIconrect.width, aseIconrect.height);
                                // GUI.Label(aseIconrectbias, IconShow(nowpathname1));
                                GUI.Label(aseIconrect, IconShow(nowpathname1));
                            }
                        }
                    }
                    /*******************************/
                }
                GUI.color = Color.white;

                /**********路径显示************/
                PathGUIshow(elepos, elepos0temp, elepos, nowpathname1, i, new Rect(elepos.x, elepos.y + columnheight / texttimer * (texttimer - 1), rowwidth, columnheight / texttimer), 0, clampzoom2);
                /*******************************/
            }



            /*****************双击定位相关******************/
            float newoutputwh = clampzoom3;
            Rect newoutputListIsSelectedrect = new Rect(outputListIsSelectedrect.x + 4, outputListIsSelectedrect.y + 4, outputListIsSelectedrect.width / newoutputwh, outputListIsSelectedrect.height / newoutputwh);
            if (aSETnodes[i].ListRectPos.Contains(ec.mousePosition))
            {
                iscancelcurrent = false;

                /********************检测被引用*****************/
                if (ec.type == EventType.MouseUp && ec.button == 1)
                {
                    GenericMenu GMenu = new GenericMenu();
                    GMenu.AddItem(new GUIContent("See Reverse dependent Files"), false, DpendendenCallback, nowpathname1);
                    GMenu.ShowAsContext();
                }
                /**********************************************/
            }
            if (!(aSETnodes[i].ListRectPos.Contains(ec.mousePosition) && !newoutputListIsSelectedrect.Contains(ec.mousePosition)))
            {
                newoutputwh = Mathf.Clamp(_zoom, 0.3f, 1f);
            }
            newoutputListIsSelectedrect = new Rect(outputListIsSelectedrect.x + 4, outputListIsSelectedrect.y + 4, outputListIsSelectedrect.width / newoutputwh, outputListIsSelectedrect.height / newoutputwh);
            bool isasetnoderectmouse = newoutputListIsSelectedrect.Contains(ec.mousePosition);

            Rect dynamiclistrectpos = aSETnodes[i].ListMouseClickIsSelected ? new Rect(elepos.x, elepos.y, elepos.width, elepos.height * 2 / 3) : elepos;
            if (dynamiclistrectpos.Contains(ec.mousePosition))
            {
                if (!isasetnoderectmouse)
                {
                    if (ec.type == EventType.MouseDown)
                    {
                        if (ec.button == 0 && !zoomexpandbuttonrect.Contains(ec.mousePosition))    //使其不与右键双击后的GUI冲突)
                        {
                            clickcount++;
                            if (clickcount > 1)
                            {
                                if (sffict != null)
                                {
                                    UnityEngine.Object obj = AssetDatabase.LoadAssetAtPath(nowpathname1, sffict);
                                    EditorGUIUtility.PingObject(obj);   //定位
                                    Selection.activeObject = obj;   //点击
                                }
                                else
                                {
                                    ShowNotification(new GUIContent("Cannot locate the file, please install related package or search for file manually"), 3.0f);
                                }
                                clickcountime = 0.0f;
                                clickcount = 0;
                            }
                            Singlemultiselect(asetnodeval.asetindex, nowtypename1);
                        }
                        // Event.current.Use(); //同Repaint()以及GUI.changed = true;但是这个use可能会导致像toggle类的无法触发
                        GUI.changed = true;
                        // Repaint();
                    }
                }
                iscancelcurrent = false;
            }
            /***********************************/

            /**********选择勾相关************/
            MyCustomToggle(i, clampzoom, newoutputListIsSelectedrect);
            /*******************************/

            allnoneselectdependIS0temp &= aSETnodes[i].outputListIsSelected;
            if (allnoneselectdependIS[1])
            {
                aSETnodes[i].outputListIsSelected = allnoneselectdependIS[0];
            }

            if (UselessMatexModel.Contains(i))
            {
                if (aSETnodes[i].outputListIsSelected)
                {
                    allhidnowcount++;
                }
                if (allnoneselectdependIS[7])
                {
                    aSETnodes[i].outputListIsSelected = allnoneselectdependIS[6];
                }
                allnoneselectdependIS6temp &= aSETnodes[i].outputListIsSelected;
            }
        }
        allnoneselectdependIS[0] = allnoneselectdependIS0temp;
        allnoneselectdependIS[2] = allnoneselectdependIS2temp;
        allnoneselectdependIS[4] = allnoneselectdependIS4temp;
        allnoneselectdependIS[6] = allnoneselectdependIS6temp;

        /**********重置相关************/
        float eleposnowtemptime0 = 1f;
        float eleposnowtemptime1 = 3f;
        if ((Event.current.type == EventType.MouseUp || Event.current.type == EventType.MouseDown) && Event.current.button == 2)
        {
            zoomstartvaluetime = eleposnowtemptime0;
            GUI.changed = true;
        }
        if (zoomstartvaluetime >= eleposnowtemptime0 && zoomstartvaluetime < eleposnowtemptime1)
        {
            zoomstartvaluetime += Time.deltaTime;
            GUI.changed = true;
        }
        else
        {
            zoomstartvaluetime = 0.0f;
            GUI.changed = true;
        }
        float eleposnowtemptimehalf01 = (eleposnowtemptime1 - eleposnowtemptime0) / 2f;
        if (zoomstartvaluetime > eleposnowtemptimehalf01)
        {
            float realheight = position.height - (25.5f + 62f);
            float realwidth = position.width - (4 + 8);
            float zoomdivideheadrow2 = Mathf.Abs(zoomdividewidthhead2 - zoomdividewidthhead) + rowwidth + 300;
            float zoomdivideheadrow = zoomdivideheadrow2;
            float zoomdivideheadcolumn2 = Mathf.Abs(zoomdivideheighthead2 - zoomdivideheighthead) + columnheight + 300;
            float zoomdivideheadcolumn = zoomdivideheadcolumn2;
            _zoom = Mathf.Min(1f, realheight / zoomdivideheadcolumn, realwidth / zoomdivideheadrow);
            if (ASETnodeallcount > 1)
            {
                float zoomx = zoomdividewidthhead - elepos0temp.x - (realwidth / 2 / _zoom - zoomdivideheadrow2 / 2) - 137f;
                float zoomy = zoomdivideheighthead - elepos0temp.y - (realheight / 2 / _zoom - zoomdivideheadcolumn2 / 2) - (17.185f / _zoom + 178.78f);
                _zoomCoordsOrigin = new Vector2(zoomx, zoomy);
            }
            else
            {
                _zoomCoordsOrigin = new Vector2(-(position.width - (4 + 8) - rowwidth) / 2, -(position.height - (25.5f + 62f) - columnheight) / 2);
                _zoomCoordsOrigin += eleposnowtemp;
            }
            GUI.changed = true;
        }
        /*****************************/

        allnoneselectdependIS[1] = false;
        allnoneselectdependIS[3] = false;
        allnoneselectdependIS[5] = false;
        allnoneselectdependIS[7] = false;
    }


    private int nowsearchindex = 0;
    private int nowsearchindextemp = -1;
    private void PathGUIshow(Rect elepos, Vector2 elepos0temp, Rect colorbox, string nowpathname1, string i, Rect pathstringrect, int GUIfontsize, float clampzoom2)        //节点内路径显示相关
    {
        if (Search.Length > 0 && nowpathname1.Contains(Search))     //搜索
        {
            aSETnodes[i].SearchListindex = SearchNum;
            SearchNum++;


            bool nowzoomd = nowsearchindex == aSETnodes[i].SearchListindex;

            // textStyleText.normal.textColor = nowzoomd ? new Color(1f, 0.54f, 0.21f, 1.0f) : new Color(0.75f, 0.66f, 0.0f, 1.0f);


            // float eleposnowtemptime0 = 1f;
            // float eleposnowtemptime1 = 30f;
            // if (nowzoomd && nowsearchindex != nowsearchindextemp)
            // {
            //     nowsearchindextemptime = eleposnowtemptime0;
            //     GUI.changed = true;
            //     nowsearchindextemp = nowsearchindex;
            // }
            // if (nowsearchindextemptime >= eleposnowtemptime0 && nowsearchindextemptime < eleposnowtemptime1)
            // {
            //     nowsearchindextemptime += Time.deltaTime;
            //     GUI.changed = true;
            // }
            // else
            // {
            //     nowsearchindextemptime = 0.0f;
            //     GUI.changed = true;
            // }
            // float eleposnowtemptimehalf01 = (eleposnowtemptime1 - eleposnowtemptime0) / 2f;
            // if (nowsearchindextemptime >= eleposnowtemptimehalf01)
            // {
            //     UnityEngine.Debug.Log(nowsearchindextemptime);
            //     _zoom = 1f;
            //     _zoomCoordsOrigin = new Vector2(-(position.width - (4 + 8) - rowwidth) / 2, -(position.height - (25.5f + 62f) - columnheight) / 2);
            //     _zoomCoordsOrigin += new Vector2(elepos.x - elepos0.x, elepos.y - elepos0.y);
            // }
            if (nowzoomd && nowsearchindex != nowsearchindextemp)
            {
                float _zoomtimer = 0.75f;
                _zoom = _zoomtimer;
                _zoomCoordsOrigin = new Vector2(-(position.width - (4 + 8) - rowwidth) / 2, -(position.height - (25.5f + 62f) - columnheight) / 2) * (1.25f / _zoomtimer);
                _zoomCoordsOrigin += new Vector2(elepos.x - elepos0temp.x, elepos.y - elepos0temp.y);
                nowsearchindextemp = nowsearchindex;
            }


            if (-pathstringrect.x < pathstringrect.width && -pathstringrect.y < pathstringrect.height)
            {
                if (pathstringrect.x < (position.width - 8) / _zoom && pathstringrect.y < (position.height - 62f) / _zoom)
                {
                    GUIStyle textStyleText = new GUIStyle("ScriptText");
                    GUI.color = nowzoomd ? new Color(1f, 0.54f, 0.21f, 1.0f) : new Color(1f, 0.9f, 0.4f, 1.0f);
                    textStyleText.richText = true;
                    textStyleText.fontStyle = FontStyle.Bold;
                    textStyleText.wordWrap = true;
                    textStyleText.fontSize = (int)(GUIfontsize / clampzoom2);
                    string tempstring = string.Empty;
                    int highlightfontsize = (int)(GUIfontsize + (ListHeadClickSeleted.Contains(nowpathname1) ? 5 : 15) / clampzoom2);
                    string richtextcolorfront = "<b><size=" + highlightfontsize + "><color=#2CD931>";
                    string richtextcolorback = "</color></size></b>";
                    int startpos = 0;
                    int richindex = -1;
                    do
                    {
                        richindex = nowpathname1.IndexOf(Search, richindex + 1);
                        if (richindex != -1)
                        {
                            tempstring += nowpathname1.Substring(startpos, richindex - startpos) + richtextcolorfront + Search + richtextcolorback;
                            startpos = richindex + Search.Length;
                        }
                    } while (richindex != -1);
                    tempstring += nowpathname1.Substring(startpos);

                    GUI.TextField(pathstringrect, tempstring, textStyleText);
                    GUI.color = Color.white;

                    GUIStyle TransparentTextField = new GUIStyle();
                    TransparentTextField.normal.textColor = Color.clear;
                    GUI.Label(pathstringrect, new GUIContent(string.Empty, nowpathname1), TransparentTextField);
                    GUI.Label(pathstringrect, GUI.tooltip, TransparentTextField);
                }
            }
            if (!iconisexist)
            {
                float colboxrectimer = 1.2f;
                float colboxrectimerxy = 0.5f * colboxrectimer - 0.5f;
                colorbox = new Rect(colorbox.x - colorbox.width * colboxrectimerxy, colorbox.y - colorbox.height * colboxrectimerxy, colorbox.width * colboxrectimer, colorbox.height * colboxrectimer);
            }
            if (-colorbox.x < colorbox.width && -colorbox.y < colorbox.height)
            {
                if (colorbox.x < (position.width - 8) / _zoom && colorbox.y < (position.height - 62f) / _zoom)
                {
                    if (!iconisexist)
                    {
                        GUI.skin = GUISKINIcons;
                        GUI.color = new Color(0.2f, 1.0f, 0.22f, 1.0f);
                        GUI.Label(colorbox, string.Empty);
                        GUI.color = Color.white;
                        GUI.skin = null;
                    }
                    else
                    {
                        GUI.color = new Color(0.0f, 1.0f, 0.0f, 1.0f);
                        GUI.Label(colorbox, string.Empty, "ControlHighlight");
                        GUI.color = Color.white;
                    }
                }
            }
        }
        else
        {
            if (-pathstringrect.x < pathstringrect.width && -pathstringrect.y < pathstringrect.height)
            {
                if (pathstringrect.x < (position.width - 8) / _zoom && pathstringrect.y < (position.height - 62f) / _zoom)
                {
                    // if (GUIfontsize == 0)
                    // GUI.color = aSETnodes[i].ListMouseClickIsSelected ? new Color(0.78f, 0.78f, 0.78f, 1.0f) : Color.white * 0.2f;
                    GUI.color = Color.white * (EditorGUIUtility.isProSkin ? 1 : 0.85f);

                    GUIStyle TransparentTextField = new GUIStyle();
                    TransparentTextField.normal.textColor = Color.clear;
                    // TransparentTextField.normal.background = MakeTex(1, 1, Color.white);
                    GUI.Label(pathstringrect, new GUIContent(string.Empty, nowpathname1), TransparentTextField);
                    GUI.Label(pathstringrect, GUI.tooltip, TransparentTextField);


                    GUIStyle TextGUIs = new GUIStyle("ScriptText");
                    TextGUIs.fontSize = (int)(GUIfontsize / clampzoom2);
                    // TextGUIs.normal.background = MakeTex(1, 1, new Color(0.78f, 0.78f, 0.78f, 1.0f));
                    TextGUIs.wordWrap = true;
                    GUI.TextField(pathstringrect, nowpathname1, TextGUIs);


                    // if (aSETnodes[i].ListMouseClickIsSelected)
                    // if (GUIfontsize == 0)
                    // {
                    GUI.color = Color.white;
                    // }
                }
            }
        }
    }
    private void MyCustomToggle(string asetkey, float clampzoom, Rect newoutputListIsSelectedrect)
    {
        bool asetolis = aSETnodes[asetkey].outputListIsSelected;
        bool jisisselected = aSETnodes[asetkey].ListIsSelected;

        aSETnodes[asetkey].outerclickwhiteboxgrid = newoutputListIsSelectedrect;
        if (-newoutputListIsSelectedrect.x < newoutputListIsSelectedrect.width && -newoutputListIsSelectedrect.y < newoutputListIsSelectedrect.height)
        {
            if (newoutputListIsSelectedrect.x < (position.width - 8) / _zoom && newoutputListIsSelectedrect.y < (position.height - 62f) / _zoom)
            {
                if (!iconisexist)
                {
                    GUI.skin = GUISKINIcons;
                    if (UselessMatexModel.Contains(asetkey))
                    {
                        GUI.color = new Color(0.2f, 0.08f, 0.2f, 1f);
                    }
                    else
                    {
                        GUI.color = jisisselected ? new Color(0.08f, 0.08f, 0.2f, 1f) : new Color(0.2f, 0.08f, 0.08f, 1f);
                    }
                    // GUI.skin.box.border = new RectOffset(0, 0, 0, 0);
                    GUIStyle Whiteboxbuttom = new GUIStyle("box");
                    Whiteboxbuttom.border = new RectOffset(0, 0, 0, 0);
                    GUI.Box(newoutputListIsSelectedrect, string.Empty, Whiteboxbuttom);
                    GUI.color = Color.white;
                    if (aSETnodes[asetkey].outputListIsSelected)
                    {
                        GUI.Label(newoutputListIsSelectedrect, string.Empty, "tick");
                    }
                    // GUI.skin.box.border = new RectOffset(25, 25, 25, 25);
                    GUI.skin = null;
                }
                else
                {
                    GUIStyle outerselectedfont = new GUIStyle();
                    outerselectedfont.normal.textColor = new Color(0.5f, 0.5f, 1.0f, 1.0f);

                    if (UselessMatexModel.Contains(asetkey))
                    {
                        GUI.color = new Color(0.5f, 0.22f, 0.5f, 1f);
                    }
                    else
                    {
                        GUI.color = jisisselected ? new Color(0.12f, 0.22f, 0.5f, 1f) : new Color(0.32f, 0.11f, 0.15f, 1f);
                    }

                    GUI.Box(newoutputListIsSelectedrect, string.Empty, "window");
                    GUI.color = Color.white;

                    if (asetolis)
                    {
                        outerselectedfont.normal.textColor = new Color(0.9f, 0.9f, 0.9f, 1f);
                        outerselectedfont.contentOffset = new Vector2(0, 12f * clampzoom - 14f);
                        outerselectedfont.fontSize = (int)newoutputListIsSelectedrect.width;
                        GUI.Label(newoutputListIsSelectedrect, "✔", outerselectedfont);
                    }
                }
            }
        }

        if (newoutputListIsSelectedrect.Contains(Event.current.mousePosition))
        {
            if (!iconisexist)
            {
                GUI.skin = GUISKINIcons;
                GUIStyle whiteboxrect = new GUIStyle("label");
                int whiteboxratio = (int)Mathf.Clamp(115.28f / _zoom - 394.25f, 0, 52);
                // whiteboxrect.border = new RectOffset(int.Parse(test), int.Parse(test), int.Parse(test), int.Parse(test));
                whiteboxrect.border = new RectOffset(whiteboxratio, whiteboxratio, whiteboxratio, whiteboxratio);
                // UnityEngine.Debug.Log(_zoom);
                // UnityEngine.Debug.Log(1 / _zoom);

                // float oputsdtimer = 1.1f;
                // float oputsdtimer1 = 0.5f * oputsdtimer - 0.5f;
                // Rect new1newoutputListIsSelectedrect = new Rect(newoutputListIsSelectedrect.x - newoutputListIsSelectedrect.width * oputsdtimer1, newoutputListIsSelectedrect.y - newoutputListIsSelectedrect.height * oputsdtimer1, newoutputListIsSelectedrect.width * oputsdtimer, newoutputListIsSelectedrect.height * oputsdtimer);
                // GUI.Box(new1newoutputListIsSelectedrect, string.Empty, whiteboxrect);
                GUI.Box(newoutputListIsSelectedrect, string.Empty, whiteboxrect);
                GUI.skin = null;
            }
            if (Event.current.type == EventType.MouseDown && Event.current.button == 0)
            {
                aSETnodes[asetkey].outputListIsSelected = !aSETnodes[asetkey].outputListIsSelected;
            }
        }
    }
    private void DrawGrid(Vector2 gridarea, float gridSpacing, float linewidth1, Color gridColor)
    {
        Vector2 scalingtimer = Vector2.one * (3755.6f / kZoomMin - 3667.7f);
        int widthDivs = Mathf.CeilToInt((gridarea.x + scalingtimer.x) / gridSpacing);
        int heightDivs = Mathf.CeilToInt((gridarea.y + scalingtimer.y) / gridSpacing);
        // UnityEngine.Debug.Log(GridOffset);

        //绘制所有的竖线
        GUI.color = gridColor;
        for (int i = 0; i < widthDivs; i++)
        {
            // Handles.DrawLine(new Vector3(i * 20 + 20, position.height, 0), new Vector3(i * 20 + 20, 0, 0f));    //该方法无法设置粗细
            float wid = i * gridSpacing - _zoomCoordsOrigin.x % (gridSpacing * 5) - scalingtimer.x / 2;
            if (i % 5 == 0)
            {
                GUI.DrawTexture(new Rect(wid, -_zoomCoordsOrigin.y % 1, linewidth1 * 2f, gridarea.y + (927.85f / kZoomMin - 1038.9f)), EditorGUIUtility.whiteTexture);
            }
            else
            {
                GUI.DrawTexture(new Rect(wid, -_zoomCoordsOrigin.y % 1, linewidth1, gridarea.y + (927.85f / kZoomMin - 1038.9f)), EditorGUIUtility.whiteTexture);
            }
        }
        for (int i = 0; i < heightDivs; i++)
        {
            float hei = i * gridSpacing - _zoomCoordsOrigin.y % (gridSpacing * 5) - scalingtimer.y / 2;
            if (i % 5 == 0)
            {
                GUI.DrawTexture(new Rect(-_zoomCoordsOrigin.x % 1, hei, gridarea.x + (1914f / kZoomMin - 1925), linewidth1 * 2f), EditorGUIUtility.whiteTexture);
            }
            else
            {
                GUI.DrawTexture(new Rect(-_zoomCoordsOrigin.x % 1, hei, gridarea.x + (1914f / kZoomMin - 1925), linewidth1), EditorGUIUtility.whiteTexture);
            }
        }
        GUI.color = Color.white;
    }

    private void DrawLineFrame(Rect drawlinerect, Color drawlinecolor, float drawlinewidth)     //自定义一个方框
    {
        if (-drawlinerect.x < drawlinerect.width && -drawlinerect.y < drawlinerect.height)
        {
            if (drawlinerect.x < (position.width - 8) / _zoom && drawlinerect.y < (position.height - 62f) / _zoom)
            {
                // 设置线框颜色
                // Handles.color = drawlinecolor;
                GUI.color = drawlinecolor;

                // 绘制四个边
                // 上边
                GUI.DrawTexture(new Rect(drawlinerect.x, drawlinerect.y, drawlinerect.width, drawlinewidth), EditorGUIUtility.whiteTexture);
                // 下边
                GUI.DrawTexture(new Rect(drawlinerect.x, drawlinerect.yMax - drawlinewidth, drawlinerect.width, drawlinewidth), EditorGUIUtility.whiteTexture);
                // 左边
                GUI.DrawTexture(new Rect(drawlinerect.x, drawlinerect.y, drawlinewidth, drawlinerect.height), EditorGUIUtility.whiteTexture);
                // 右边
                GUI.DrawTexture(new Rect(drawlinerect.xMax - drawlinewidth, drawlinerect.y, drawlinewidth, drawlinerect.height), EditorGUIUtility.whiteTexture);

                // 重置颜色
                // Handles.color = Color.white;
                GUI.color = Color.white;
            }
        }
    }


    /*********************Zoom所有算法*************************/
    /*********************Zoom可见区域算法*************************/
    private static readonly float kEditorWindowTabHeight = 21.0f;
    private Matrix4x4 _prevGuiMatrix;
    private Rect ScaleSizeBy(Rect SSrect, float SSscale, Vector2 pivotPoint)
    {
        Rect result = SSrect;
        result.x -= pivotPoint.x;
        result.y -= pivotPoint.y;
        result.xMin *= SSscale;
        result.xMax *= SSscale;
        result.yMin *= SSscale;
        result.yMax *= SSscale;
        result.x += pivotPoint.x;
        result.y += pivotPoint.y;
        return result;
    }

    private Rect ZoomBegin(float zoomScale, Rect screenCoordsArea)
    {
        GUI.EndGroup();        // End the group Unity begins automatically for an EditorWindow to clip out the window tab. This allows us to draw outside of the size of the EditorWindow.

        Rect clippedArea = ScaleSizeBy(screenCoordsArea, 1.0f / zoomScale, new Vector2(screenCoordsArea.xMin, screenCoordsArea.yMin));
        clippedArea.y += kEditorWindowTabHeight;
        GUI.BeginGroup(clippedArea);

        _prevGuiMatrix = GUI.matrix;
        Matrix4x4 translation = Matrix4x4.TRS(new Vector2(clippedArea.xMin, clippedArea.yMin), Quaternion.identity, Vector3.one);
        Matrix4x4 scale = Matrix4x4.Scale(new Vector3(zoomScale, zoomScale, 1.0f));
        GUI.matrix = translation * scale * translation.inverse * GUI.matrix;

        return clippedArea;
    }

    private void ZoomEnd()
    {
        GUI.matrix = _prevGuiMatrix;
        GUI.EndGroup();
        GUI.BeginGroup(new Rect(0.0f, kEditorWindowTabHeight, Screen.width, Screen.height));
    }
    /*********************Zoom可见区域算法*************************/

    private static readonly float kZoomMin = 0.025f;
    private static readonly float kZoomMax = 2f;
    private Rect _zoomArea = new Rect(4, 25.5f, 100, 100);
    private float _zoom = 0.25f;
    private Vector2 _zoomCoordsOrigin = Vector2.zero;
    private void HandleEvents()
    {
        // Allow adjusting the zoom with the mouse wheel as well. In this case, use the mouse coordinates
        // as the zoom center instead of the top left corner of the zoom area. This is achieved by
        // maintaining an origin that is used as offset when drawing any GUI elements in the zoom area.
        if (Event.current.type == EventType.ScrollWheel)
        {
            Vector2 screenCoordsMousePos = Event.current.mousePosition;
            Vector2 ecdelta = Event.current.delta;
            // Vector2 zoomCoordsMousePos = ConvertScreenCoordsToZoomCoords(screenCoordsMousePos);
            Vector2 zoomCoordsMousePos = (screenCoordsMousePos - new Vector2(_zoomArea.xMin, _zoomArea.yMin)) / _zoom + _zoomCoordsOrigin;
            float zoomDelta = -ecdelta.y / 90;  //鼠标灵敏度
            float oldZoom = _zoom;
            _zoom += zoomDelta;
            _zoom = Mathf.Clamp(_zoom, kZoomMin, kZoomMax);  //限制范围
            _zoomCoordsOrigin += (zoomCoordsMousePos - _zoomCoordsOrigin) - (oldZoom / _zoom) * (zoomCoordsMousePos - _zoomCoordsOrigin);

            Event.current.Use();
        }

        // Allow moving the zoom area's origin by dragging with the middle mouse button or dragging
        // with the left mouse button with Alt pressed.
        // if (Event.current.type == EventType.MouseDrag && ((Event.current.button == 0 && Event.current.modifiers == EventModifiers.Alt) || Event.current.button == 2))
        if (Event.current.type == EventType.MouseDrag && (Event.current.button == 1))
        {
            Vector2 ecdelta = Event.current.delta;
            ecdelta /= _zoom;
            _zoomCoordsOrigin -= ecdelta;

            Event.current.Use();
        }
    }

    /*********************Zoom所有算法*************************/


    private Texture2D MakeTex(int maketexwidth, int maketexheight, Color maketexcolor)
    {
        Color32[] pix = new Color32[maketexwidth * maketexheight];
        for (int i = 0; i < pix.Length; i++)
        {
            pix[i] = maketexcolor;
        }
        Texture2D result = new Texture2D(maketexwidth, maketexheight);
        result.SetPixels32(pix);
        result.Apply();
        return result;
    }

    private static readonly string Stringmeta = ".meta";
    private Type IconShowType(string rc)
    {
        return AssetDatabase.GetMainAssetTypeAtPath(rc);
    }
    private bool IsSuff(string path, string pattern)
    {
        int pL = path.Length - 1;
        int paL = pattern.Length - 1;
        bool Isuff = true;
        for (int i = pL; paL >= 0; i--)
        {
            char pathi = path[i];
            char patterni = pattern[paL];
            Isuff &= pathi == patterni;
            if (!Isuff || pathi == '.' || patterni == '.')
            {
                break;
            }
            paL--;
        }
        return Isuff;
    }
    private GUIContent IconShow(string reference)
    {
        Type Assettype = IconShowType(reference) ?? typeof(DefaultAsset);
        string typename1 = GetIconName(reference, Assettype.Name);
        GUIContent finalGUIcont = EditorGUIUtility.IconContent(typename1);
        return finalGUIcont;
    }
    private string GetIconName(string NameSuff, string typeName)
    {
        bool prefabcase = IsSuff(NameSuff, ".prefab");
        bool unitypackagecase = IsSuff(NameSuff, ".unitypackage");
        bool dllcase = IsSuff(NameSuff, ".dll");
        bool typenamecase0 = typeName == "GameObject" && !prefabcase;
        bool typenamecase1 = typeName == "DefaultAsset" && !unitypackagecase && !dllcase || typeName == "TerrainLayer";

        switch (typeName)
        {
            case string _ when typenamecase0: return (EditorGUIUtility.isProSkin ? "d_" : string.Empty) + "PrefabModel Icon";
            case string _ when typenamecase1: return (EditorGUIUtility.isProSkin ? "d_" : string.Empty) + "DefaultAsset Icon";
            case string _ when IsSuff(NameSuff, ".cs"): return (EditorGUIUtility.isProSkin ? "d_" : string.Empty) + "cs Script Icon";
            case string _ when prefabcase: return (EditorGUIUtility.isProSkin ? "d_" : string.Empty) + "Prefab Icon";
            case string _ when dllcase: return "Assembly Icon";
            case string _ when IsSuff(NameSuff, ".asset") || IsSuff(NameSuff, ".shadersubgraph") || IsSuff(NameSuff, ".inputactions"): return "ScriptableObject Icon";
            case string _ when unitypackagecase: return (EditorGUIUtility.isProSkin ? "d_" : string.Empty) + "UnityLogo Icon";
            // default: return $"{typeName} Icon";
            default: return (EditorGUIUtility.isProSkin ? "d_" : string.Empty) + typeName + " Icon";
        }
    }

    private bool LowUpTrans(string source, string suf)
    {
        char lastchar = source[source.Length - 1];
        if (!char.IsLetter(lastchar))
        {
            lastchar = source[source.Length - 2];
        }
        bool final = char.IsLower(lastchar) ? IsSuff(source, suf) : IsSuff(source, suf.ToUpper());
        return final;
    }
    // private static readonly string[] ASWFolderNames = new string[] { "Materials", "Shaders", "Textures", "Prefabs", "Models", "Animations", "Animators", "Scripts", "Scenes", "Timelines", "GUISkins", "Meshes", "Sprites", "Terrains", "Audios", "Videos", "PhysicMaterials", "Lightings", "VFXs", "ComputeShaders", "Fonts", "Assets", "Others" };
    private static readonly string[] ASWFolderNames = new string[] { "Scenes", "Prefabs", "Materials", "Shaders", "Textures", "Scripts", "Models", "Animators", "Animations", "Timelines", "GUISkins", "Meshes", "Sprites", "Terrains", "Audios", "Videos", "PhysicMaterials", "Lightings", "VFXs", "ComputeShaders", "Fonts", "Assets", "Others" };
}
